{"version":3,"sources":["C:/Users/MounaBouslah/Desktop/Seekmake/Main Project/material-dashboard-pro-angular-v2.4.1/node_modules/angular-draggable-droppable/fesm5/angular-draggable-droppable.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;AAWA;;;KAGK,AAKC;;;;;;;;;gDACmM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAkCpM,AAKC;;;;;;;;;;;;;;;;;;;;oBAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA46BA,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoMA,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgBA;;;;;;;;;;KAUD;;;;;;;;;;;;;;;;;;;;;;gDAcC","file":"angular-draggable-droppable.js","sourcesContent":["import { Subject, Observable, merge, ReplaySubject, combineLatest, animationFrameScheduler, fromEvent } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { __read, __assign } from 'tslib';\nimport { Injectable, Directive, ElementRef, Input, NgModule, EventEmitter, NgZone, Renderer2, Optional, Output, defineInjectable, ViewContainerRef, Inject } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, auditTime, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar DraggableHelper = /** @class */ (function () {\n    function DraggableHelper() {\n        this.currentDrag = new Subject();\n    }\n    DraggableHelper.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] }\n    ];\n    /** @nocollapse */ DraggableHelper.ngInjectableDef = defineInjectable({ factory: function DraggableHelper_Factory() { return new DraggableHelper(); }, token: DraggableHelper, providedIn: \"root\" });\n    return DraggableHelper;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n * <div mwlDraggable>Drag me!</div>\n * </div>\n * ```\n */\nvar DraggableScrollContainerDirective = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function DraggableScrollContainerDirective(elementRef) {\n        this.elementRef = elementRef;\n        /**\n         * Trigger the DragStart after a long touch in scrollable container when true\n         * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n         */\n        this.activeLongPressDrag = false;\n        /**\n         * Configuration of a long touch\n         * Duration in ms of a long touch before activating DragStart\n         * Delta of the\n         * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n         */\n        this.longPressConfig = { duration: 300, delta: 30 };\n    }\n    DraggableScrollContainerDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[mwlDraggableScrollContainer]',\n                },] }\n    ];\n    /** @nocollapse */\n    DraggableScrollContainerDirective.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    DraggableScrollContainerDirective.propDecorators = {\n        activeLongPressDrag: [{ type: Input }],\n        longPressConfig: [{ type: Input }]\n    };\n    return DraggableScrollContainerDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToAdd\n * @return {?}\n */\nfunction addClass(renderer, element, classToAdd) {\n    if (classToAdd) {\n        classToAdd\n            .split(' ')\n            .forEach((/**\n         * @param {?} className\n         * @return {?}\n         */\n        function (className) {\n            return renderer.addClass(element.nativeElement, className);\n        }));\n    }\n}\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToRemove\n * @return {?}\n */\nfunction removeClass(renderer, element, classToRemove) {\n    if (classToRemove) {\n        classToRemove\n            .split(' ')\n            .forEach((/**\n         * @param {?} className\n         * @return {?}\n         */\n        function (className) {\n            return renderer.removeClass(element.nativeElement, className);\n        }));\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar DraggableDirective = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n        this.element = element;\n        this.renderer = renderer;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.vcr = vcr;\n        this.scrollContainer = scrollContainer;\n        this.document = document;\n        /**\n         * The axis along which the element is draggable\n         */\n        this.dragAxis = { x: true, y: true };\n        /**\n         * Snap all drags to an x / y grid\n         */\n        this.dragSnapGrid = {};\n        /**\n         * Show a ghost element that shows the drag when dragging\n         */\n        this.ghostDragEnabled = true;\n        /**\n         * Show the original element when ghostDragEnabled is true\n         */\n        this.showOriginalElementWhileDragging = false;\n        /**\n         * The cursor to use when hovering over a draggable element\n         */\n        this.dragCursor = '';\n        /*\n           * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n           */\n        this.autoScroll = {\n            margin: 20,\n        };\n        /**\n         * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n         */\n        this.dragPointerDown = new EventEmitter();\n        /**\n         * Called when the element has started to be dragged.\n         * Only called after at least one mouse or touch move event.\n         * If you call $event.cancelDrag$.emit() it will cancel the current drag\n         */\n        this.dragStart = new EventEmitter();\n        /**\n         * Called after the ghost element has been created\n         */\n        this.ghostElementCreated = new EventEmitter();\n        /**\n         * Called when the element is being dragged\n         */\n        this.dragging = new EventEmitter();\n        /**\n         * Called after the element is dragged\n         */\n        this.dragEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.pointerDown$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerMove$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerUp$ = new Subject();\n        this.eventListenerSubscriptions = {};\n        this.destroy$ = new Subject();\n        this.timeLongPress = { timerBegin: 0, timerEnd: 0 };\n    }\n    /**\n     * @return {?}\n     */\n    DraggableDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.checkEventListeners();\n        /** @type {?} */\n        var pointerDragged$ = this.pointerDown$.pipe(filter((/**\n         * @return {?}\n         */\n        function () { return _this.canDrag(); })), mergeMap((/**\n         * @param {?} pointerDownEvent\n         * @return {?}\n         */\n        function (pointerDownEvent) {\n            // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n            // stop mouse events propagating up the chain\n            if (pointerDownEvent.event.stopPropagation && !_this.scrollContainer) {\n                pointerDownEvent.event.stopPropagation();\n            }\n            // hack to prevent text getting selected in safari while dragging\n            /** @type {?} */\n            var globalDragStyle = _this.renderer.createElement('style');\n            _this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n            _this.renderer.appendChild(globalDragStyle, _this.renderer.createText(\"\\n          body * {\\n           -moz-user-select: none;\\n           -ms-user-select: none;\\n           -webkit-user-select: none;\\n           user-select: none;\\n          }\\n        \"));\n            requestAnimationFrame((/**\n             * @return {?}\n             */\n            function () {\n                _this.document.head.appendChild(globalDragStyle);\n            }));\n            /** @type {?} */\n            var startScrollPosition = _this.getScrollPosition();\n            /** @type {?} */\n            var scrollContainerScroll$ = new Observable((/**\n             * @param {?} observer\n             * @return {?}\n             */\n            function (observer) {\n                /** @type {?} */\n                var scrollContainer = _this.scrollContainer\n                    ? _this.scrollContainer.elementRef.nativeElement\n                    : 'window';\n                return _this.renderer.listen(scrollContainer, 'scroll', (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                function (e) {\n                    return observer.next(e);\n                }));\n            })).pipe(startWith(startScrollPosition), map((/**\n             * @return {?}\n             */\n            function () { return _this.getScrollPosition(); })));\n            /** @type {?} */\n            var currentDrag$ = new Subject();\n            /** @type {?} */\n            var cancelDrag$ = new ReplaySubject();\n            _this.zone.run((/**\n             * @return {?}\n             */\n            function () {\n                _this.dragPointerDown.next({ x: 0, y: 0 });\n            }));\n            /** @type {?} */\n            var dragComplete$ = merge(_this.pointerUp$, _this.pointerDown$, cancelDrag$, _this.destroy$).pipe(share());\n            /** @type {?} */\n            var pointerMove = combineLatest([\n                _this.pointerMove$,\n                scrollContainerScroll$,\n            ]).pipe(map((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            function (_a) {\n                var _b = __read(_a, 2), pointerMoveEvent = _b[0], scroll = _b[1];\n                return {\n                    currentDrag$: currentDrag$,\n                    transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                    transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                    clientX: pointerMoveEvent.clientX,\n                    clientY: pointerMoveEvent.clientY,\n                    scrollLeft: scroll.left,\n                    scrollTop: scroll.top,\n                };\n            })), map((/**\n             * @param {?} moveData\n             * @return {?}\n             */\n            function (moveData) {\n                if (_this.dragSnapGrid.x) {\n                    moveData.transformX =\n                        Math.round(moveData.transformX / _this.dragSnapGrid.x) *\n                            _this.dragSnapGrid.x;\n                }\n                if (_this.dragSnapGrid.y) {\n                    moveData.transformY =\n                        Math.round(moveData.transformY / _this.dragSnapGrid.y) *\n                            _this.dragSnapGrid.y;\n                }\n                return moveData;\n            })), map((/**\n             * @param {?} moveData\n             * @return {?}\n             */\n            function (moveData) {\n                if (!_this.dragAxis.x) {\n                    moveData.transformX = 0;\n                }\n                if (!_this.dragAxis.y) {\n                    moveData.transformY = 0;\n                }\n                return moveData;\n            })), map((/**\n             * @param {?} moveData\n             * @return {?}\n             */\n            function (moveData) {\n                /** @type {?} */\n                var scrollX = moveData.scrollLeft - startScrollPosition.left;\n                /** @type {?} */\n                var scrollY = moveData.scrollTop - startScrollPosition.top;\n                return __assign({}, moveData, { x: moveData.transformX + scrollX, y: moveData.transformY + scrollY });\n            })), filter((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            function (_a) {\n                var x = _a.x, y = _a.y, transformX = _a.transformX, transformY = _a.transformY;\n                return !_this.validateDrag ||\n                    _this.validateDrag({\n                        x: x,\n                        y: y,\n                        transform: { x: transformX, y: transformY },\n                    });\n            })), takeUntil(dragComplete$), share());\n            /** @type {?} */\n            var dragStarted$ = pointerMove.pipe(take(1), share());\n            /** @type {?} */\n            var dragEnded$ = pointerMove.pipe(takeLast(1), share());\n            dragStarted$.subscribe((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            function (_a) {\n                var clientX = _a.clientX, clientY = _a.clientY, x = _a.x, y = _a.y;\n                _this.zone.run((/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.dragStart.next({ cancelDrag$: cancelDrag$ });\n                }));\n                _this.scroller = autoScroll([\n                    _this.scrollContainer\n                        ? _this.scrollContainer.elementRef.nativeElement\n                        : _this.document.defaultView,\n                ], __assign({}, _this.autoScroll, { autoScroll: /**\n                     * @return {?}\n                     */\n                    function () {\n                        return true;\n                    } }));\n                addClass(_this.renderer, _this.element, _this.dragActiveClass);\n                if (_this.ghostDragEnabled) {\n                    /** @type {?} */\n                    var rect = _this.element.nativeElement.getBoundingClientRect();\n                    /** @type {?} */\n                    var clone_1 = (/** @type {?} */ (_this.element.nativeElement.cloneNode(true)));\n                    if (!_this.showOriginalElementWhileDragging) {\n                        _this.renderer.setStyle(_this.element.nativeElement, 'visibility', 'hidden');\n                    }\n                    if (_this.ghostElementAppendTo) {\n                        _this.ghostElementAppendTo.appendChild(clone_1);\n                    }\n                    else {\n                        (/** @type {?} */ (_this.element.nativeElement.parentNode)).insertBefore(clone_1, _this.element.nativeElement.nextSibling);\n                    }\n                    _this.ghostElement = clone_1;\n                    _this.document.body.style.cursor = _this.dragCursor;\n                    _this.setElementStyles(clone_1, {\n                        position: 'fixed',\n                        top: rect.top + \"px\",\n                        left: rect.left + \"px\",\n                        width: rect.width + \"px\",\n                        height: rect.height + \"px\",\n                        cursor: _this.dragCursor,\n                        margin: '0',\n                        willChange: 'transform',\n                        pointerEvents: 'none',\n                    });\n                    if (_this.ghostElementTemplate) {\n                        /** @type {?} */\n                        var viewRef_1 = _this.vcr.createEmbeddedView(_this.ghostElementTemplate);\n                        clone_1.innerHTML = '';\n                        viewRef_1.rootNodes\n                            .filter((/**\n                         * @param {?} node\n                         * @return {?}\n                         */\n                        function (node) { return node instanceof Node; }))\n                            .forEach((/**\n                         * @param {?} node\n                         * @return {?}\n                         */\n                        function (node) {\n                            clone_1.appendChild(node);\n                        }));\n                        dragEnded$.subscribe((/**\n                         * @return {?}\n                         */\n                        function () {\n                            _this.vcr.remove(_this.vcr.indexOf(viewRef_1));\n                        }));\n                    }\n                    _this.zone.run((/**\n                     * @return {?}\n                     */\n                    function () {\n                        _this.ghostElementCreated.emit({\n                            clientX: clientX - x,\n                            clientY: clientY - y,\n                            element: clone_1,\n                        });\n                    }));\n                    dragEnded$.subscribe((/**\n                     * @return {?}\n                     */\n                    function () {\n                        (/** @type {?} */ (clone_1.parentElement)).removeChild(clone_1);\n                        _this.ghostElement = null;\n                        _this.renderer.setStyle(_this.element.nativeElement, 'visibility', '');\n                    }));\n                }\n                _this.draggableHelper.currentDrag.next(currentDrag$);\n            }));\n            dragEnded$\n                .pipe(mergeMap((/**\n             * @param {?} dragEndData\n             * @return {?}\n             */\n            function (dragEndData) {\n                /** @type {?} */\n                var dragEndData$ = cancelDrag$.pipe(count(), take(1), map((/**\n                 * @param {?} calledCount\n                 * @return {?}\n                 */\n                function (calledCount) { return (__assign({}, dragEndData, { dragCancelled: calledCount > 0 })); })));\n                cancelDrag$.complete();\n                return dragEndData$;\n            })))\n                .subscribe((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            function (_a) {\n                var x = _a.x, y = _a.y, dragCancelled = _a.dragCancelled;\n                _this.scroller.destroy();\n                _this.zone.run((/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.dragEnd.next({ x: x, y: y, dragCancelled: dragCancelled });\n                }));\n                removeClass(_this.renderer, _this.element, _this.dragActiveClass);\n                currentDrag$.complete();\n            }));\n            merge(dragComplete$, dragEnded$)\n                .pipe(take(1))\n                .subscribe((/**\n             * @return {?}\n             */\n            function () {\n                requestAnimationFrame((/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.document.head.removeChild(globalDragStyle);\n                }));\n            }));\n            return pointerMove;\n        })), share());\n        merge(pointerDragged$.pipe(take(1), map((/**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { return [, value]; }))), pointerDragged$.pipe(pairwise()))\n            .pipe(filter((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        function (_a) {\n            var _b = __read(_a, 2), previous = _b[0], next = _b[1];\n            if (!previous) {\n                return true;\n            }\n            return previous.x !== next.x || previous.y !== next.y;\n        })), map((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        function (_a) {\n            var _b = __read(_a, 2), previous = _b[0], next = _b[1];\n            return next;\n        })), auditTime(0, animationFrameScheduler))\n            .subscribe((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        function (_a) {\n            var x = _a.x, y = _a.y, currentDrag$ = _a.currentDrag$, clientX = _a.clientX, clientY = _a.clientY, transformX = _a.transformX, transformY = _a.transformY;\n            _this.zone.run((/**\n             * @return {?}\n             */\n            function () {\n                _this.dragging.next({ x: x, y: y });\n            }));\n            if (_this.ghostElement) {\n                /** @type {?} */\n                var transform = \"translate3d(\" + transformX + \"px, \" + transformY + \"px, 0px)\";\n                _this.setElementStyles(_this.ghostElement, {\n                    transform: transform,\n                    '-webkit-transform': transform,\n                    '-ms-transform': transform,\n                    '-moz-transform': transform,\n                    '-o-transform': transform,\n                });\n            }\n            currentDrag$.next({\n                clientX: clientX,\n                clientY: clientY,\n                dropData: _this.dropData,\n            });\n        }));\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    DraggableDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes.dragAxis) {\n            this.checkEventListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    DraggableDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.checkEventListeners = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var canDrag = this.canDrag();\n        /** @type {?} */\n        var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n        if (canDrag && !hasEventListeners) {\n            this.zone.runOutsideAngular((/**\n             * @return {?}\n             */\n            function () {\n                _this.eventListenerSubscriptions.mousedown = _this.renderer.listen(_this.element.nativeElement, 'mousedown', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                function (event) {\n                    _this.onMouseDown(event);\n                }));\n                _this.eventListenerSubscriptions.mouseup = _this.renderer.listen('document', 'mouseup', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                function (event) {\n                    _this.onMouseUp(event);\n                }));\n                _this.eventListenerSubscriptions.touchstart = _this.renderer.listen(_this.element.nativeElement, 'touchstart', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                function (event) {\n                    _this.onTouchStart(event);\n                }));\n                _this.eventListenerSubscriptions.touchend = _this.renderer.listen('document', 'touchend', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                function (event) {\n                    _this.onTouchEnd(event);\n                }));\n                _this.eventListenerSubscriptions.touchcancel = _this.renderer.listen('document', 'touchcancel', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                function (event) {\n                    _this.onTouchEnd(event);\n                }));\n                _this.eventListenerSubscriptions.mouseenter = _this.renderer.listen(_this.element.nativeElement, 'mouseenter', (/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.onMouseEnter();\n                }));\n                _this.eventListenerSubscriptions.mouseleave = _this.renderer.listen(_this.element.nativeElement, 'mouseleave', (/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.onMouseLeave();\n                }));\n            }));\n        }\n        else if (!canDrag && hasEventListeners) {\n            this.unsubscribeEventListeners();\n        }\n    };\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DraggableDirective.prototype.onMouseDown = /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        var _this = this;\n        if (event.button === 0) {\n            if (!this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', (/**\n                 * @param {?} mouseMoveEvent\n                 * @return {?}\n                 */\n                function (mouseMoveEvent) {\n                    _this.pointerMove$.next({\n                        event: mouseMoveEvent,\n                        clientX: mouseMoveEvent.clientX,\n                        clientY: mouseMoveEvent.clientY,\n                    });\n                }));\n            }\n            this.pointerDown$.next({\n                event: event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    };\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DraggableDirective.prototype.onMouseUp = /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (event.button === 0) {\n            if (this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove();\n                delete this.eventListenerSubscriptions.mousemove;\n            }\n            this.pointerUp$.next({\n                event: event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    };\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DraggableDirective.prototype.onTouchStart = /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        var _this = this;\n        /** @type {?} */\n        var startScrollPosition;\n        /** @type {?} */\n        var isDragActivated;\n        /** @type {?} */\n        var hasContainerScrollbar;\n        if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n            this.touchStartLongPress) {\n            this.timeLongPress.timerBegin = Date.now();\n            isDragActivated = false;\n            hasContainerScrollbar = this.hasScrollbar();\n            startScrollPosition = this.getScrollPosition();\n        }\n        if (!this.eventListenerSubscriptions.touchmove) {\n            /** @type {?} */\n            var contextMenuListener_1 = fromEvent(this.document, 'contextmenu').subscribe((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                e.preventDefault();\n            }));\n            /** @type {?} */\n            var touchMoveListener_1 = fromEvent(this.document, 'touchmove', {\n                passive: false,\n            }).subscribe((/**\n             * @param {?} touchMoveEvent\n             * @return {?}\n             */\n            function (touchMoveEvent) {\n                if (((_this.scrollContainer && _this.scrollContainer.activeLongPressDrag) ||\n                    _this.touchStartLongPress) &&\n                    !isDragActivated &&\n                    hasContainerScrollbar) {\n                    isDragActivated = _this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n                }\n                if (((!_this.scrollContainer ||\n                    !_this.scrollContainer.activeLongPressDrag) &&\n                    !_this.touchStartLongPress) ||\n                    !hasContainerScrollbar ||\n                    isDragActivated) {\n                    touchMoveEvent.preventDefault();\n                    _this.pointerMove$.next({\n                        event: touchMoveEvent,\n                        clientX: touchMoveEvent.targetTouches[0].clientX,\n                        clientY: touchMoveEvent.targetTouches[0].clientY,\n                    });\n                }\n            }));\n            this.eventListenerSubscriptions.touchmove = (/**\n             * @return {?}\n             */\n            function () {\n                contextMenuListener_1.unsubscribe();\n                touchMoveListener_1.unsubscribe();\n            });\n        }\n        this.pointerDown$.next({\n            event: event,\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY,\n        });\n    };\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DraggableDirective.prototype.onTouchEnd = /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n            this.eventListenerSubscriptions.touchmove();\n            delete this.eventListenerSubscriptions.touchmove;\n            if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n                this.touchStartLongPress) {\n                this.enableScroll();\n            }\n        }\n        this.pointerUp$.next({\n            event: event,\n            clientX: event.changedTouches[0].clientX,\n            clientY: event.changedTouches[0].clientY,\n        });\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.onMouseEnter = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.setCursor(this.dragCursor);\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.onMouseLeave = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.setCursor('');\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.canDrag = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        return this.dragAxis.x || this.dragAxis.y;\n    };\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    DraggableDirective.prototype.setCursor = /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n            this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.unsubscribeEventListeners = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        Object.keys(this.eventListenerSubscriptions).forEach((/**\n         * @param {?} type\n         * @return {?}\n         */\n        function (type) {\n            ((/** @type {?} */ (_this))).eventListenerSubscriptions[type]();\n            delete ((/** @type {?} */ (_this))).eventListenerSubscriptions[type];\n        }));\n    };\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styles\n     * @return {?}\n     */\n    DraggableDirective.prototype.setElementStyles = /**\n     * @private\n     * @param {?} element\n     * @param {?} styles\n     * @return {?}\n     */\n    function (element, styles) {\n        var _this = this;\n        Object.keys(styles).forEach((/**\n         * @param {?} key\n         * @return {?}\n         */\n        function (key) {\n            _this.renderer.setStyle(element, key, styles[key]);\n        }));\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.getScrollElement = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.scrollContainer) {\n            return this.scrollContainer.elementRef.nativeElement;\n        }\n        else {\n            return this.document.body;\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.getScrollPosition = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.scrollContainer) {\n            return {\n                top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n                left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n            };\n        }\n        else {\n            return {\n                top: window.pageYOffset || this.document.documentElement.scrollTop,\n                left: window.pageXOffset || this.document.documentElement.scrollLeft,\n            };\n        }\n    };\n    /**\n     * @private\n     * @param {?} event\n     * @param {?} touchMoveEvent\n     * @param {?} startScrollPosition\n     * @return {?}\n     */\n    DraggableDirective.prototype.shouldBeginDrag = /**\n     * @private\n     * @param {?} event\n     * @param {?} touchMoveEvent\n     * @param {?} startScrollPosition\n     * @return {?}\n     */\n    function (event, touchMoveEvent, startScrollPosition) {\n        /** @type {?} */\n        var moveScrollPosition = this.getScrollPosition();\n        /** @type {?} */\n        var deltaScroll = {\n            top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n            left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n        };\n        /** @type {?} */\n        var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        /** @type {?} */\n        var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        /** @type {?} */\n        var deltaTotal = deltaX + deltaY;\n        /** @type {?} */\n        var longPressConfig = this.touchStartLongPress\n            ? this.touchStartLongPress\n            : /* istanbul ignore next */\n                {\n                    delta: this.scrollContainer.longPressConfig.delta,\n                    delay: this.scrollContainer.longPressConfig.duration,\n                };\n        if (deltaTotal > longPressConfig.delta ||\n            deltaScroll.top > 0 ||\n            deltaScroll.left > 0) {\n            this.timeLongPress.timerBegin = Date.now();\n        }\n        this.timeLongPress.timerEnd = Date.now();\n        /** @type {?} */\n        var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n        if (duration >= longPressConfig.delay) {\n            this.disableScroll();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.enableScroll = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', '');\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.disableScroll = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        /* istanbul ignore next */\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    DraggableDirective.prototype.hasScrollbar = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var scrollContainer = this.getScrollElement();\n        /** @type {?} */\n        var containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n        /** @type {?} */\n        var containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n    };\n    DraggableDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[mwlDraggable]',\n                },] }\n    ];\n    /** @nocollapse */\n    DraggableDirective.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Renderer2 },\n        { type: DraggableHelper },\n        { type: NgZone },\n        { type: ViewContainerRef },\n        { type: DraggableScrollContainerDirective, decorators: [{ type: Optional }] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    DraggableDirective.propDecorators = {\n        dropData: [{ type: Input }],\n        dragAxis: [{ type: Input }],\n        dragSnapGrid: [{ type: Input }],\n        ghostDragEnabled: [{ type: Input }],\n        showOriginalElementWhileDragging: [{ type: Input }],\n        validateDrag: [{ type: Input }],\n        dragCursor: [{ type: Input }],\n        dragActiveClass: [{ type: Input }],\n        ghostElementAppendTo: [{ type: Input }],\n        ghostElementTemplate: [{ type: Input }],\n        touchStartLongPress: [{ type: Input }],\n        autoScroll: [{ type: Input }],\n        dragPointerDown: [{ type: Output }],\n        dragStart: [{ type: Output }],\n        ghostElementCreated: [{ type: Output }],\n        dragging: [{ type: Output }],\n        dragEnd: [{ type: Output }]\n    };\n    return DraggableDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n    return (clientX >= rect.left &&\n        clientX <= rect.right &&\n        clientY >= rect.top &&\n        clientY <= rect.bottom);\n}\nvar DroppableDirective = /** @class */ (function () {\n    function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {\n        this.element = element;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.scrollContainer = scrollContainer;\n        /**\n         * Called when a draggable element starts overlapping the element\n         */\n        this.dragEnter = new EventEmitter();\n        /**\n         * Called when a draggable element stops overlapping the element\n         */\n        this.dragLeave = new EventEmitter();\n        /**\n         * Called when a draggable element is moved over the element\n         */\n        this.dragOver = new EventEmitter();\n        /**\n         * Called when a draggable element is dropped on this element\n         */\n        this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n    }\n    /**\n     * @return {?}\n     */\n    DroppableDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((/**\n         * @param {?} drag$\n         * @return {?}\n         */\n        function (drag$) {\n            addClass(_this.renderer, _this.element, _this.dragActiveClass);\n            /** @type {?} */\n            var droppableElement = {\n                updateCache: true,\n            };\n            /** @type {?} */\n            var deregisterScrollListener = _this.renderer.listen(_this.scrollContainer\n                ? _this.scrollContainer.elementRef.nativeElement\n                : 'window', 'scroll', (/**\n             * @return {?}\n             */\n            function () {\n                droppableElement.updateCache = true;\n            }));\n            /** @type {?} */\n            var currentDragDropData;\n            /** @type {?} */\n            var overlaps$ = drag$.pipe(map((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            function (_a) {\n                var clientX = _a.clientX, clientY = _a.clientY, dropData = _a.dropData;\n                currentDragDropData = dropData;\n                if (droppableElement.updateCache) {\n                    droppableElement.rect = _this.element.nativeElement.getBoundingClientRect();\n                    if (_this.scrollContainer) {\n                        droppableElement.scrollContainerRect = _this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n                    }\n                    droppableElement.updateCache = false;\n                }\n                /** @type {?} */\n                var isWithinElement = isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.rect)));\n                if (droppableElement.scrollContainerRect) {\n                    return (isWithinElement &&\n                        isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.scrollContainerRect))));\n                }\n                else {\n                    return isWithinElement;\n                }\n            })));\n            /** @type {?} */\n            var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n            /** @type {?} */\n            var dragOverActive;\n            overlapsChanged$\n                .pipe(filter((/**\n             * @param {?} overlapsNow\n             * @return {?}\n             */\n            function (overlapsNow) { return overlapsNow; })))\n                .subscribe((/**\n             * @return {?}\n             */\n            function () {\n                dragOverActive = true;\n                addClass(_this.renderer, _this.element, _this.dragOverClass);\n                _this.zone.run((/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.dragEnter.next({\n                        dropData: currentDragDropData,\n                    });\n                }));\n            }));\n            overlaps$.pipe(filter((/**\n             * @param {?} overlapsNow\n             * @return {?}\n             */\n            function (overlapsNow) { return overlapsNow; }))).subscribe((/**\n             * @return {?}\n             */\n            function () {\n                _this.zone.run((/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.dragOver.next({\n                        dropData: currentDragDropData,\n                    });\n                }));\n            }));\n            overlapsChanged$\n                .pipe(pairwise(), filter((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            function (_a) {\n                var _b = __read(_a, 2), didOverlap = _b[0], overlapsNow = _b[1];\n                return didOverlap && !overlapsNow;\n            })))\n                .subscribe((/**\n             * @return {?}\n             */\n            function () {\n                dragOverActive = false;\n                removeClass(_this.renderer, _this.element, _this.dragOverClass);\n                _this.zone.run((/**\n                 * @return {?}\n                 */\n                function () {\n                    _this.dragLeave.next({\n                        dropData: currentDragDropData,\n                    });\n                }));\n            }));\n            drag$.subscribe({\n                complete: (/**\n                 * @return {?}\n                 */\n                function () {\n                    deregisterScrollListener();\n                    removeClass(_this.renderer, _this.element, _this.dragActiveClass);\n                    if (dragOverActive) {\n                        removeClass(_this.renderer, _this.element, _this.dragOverClass);\n                        _this.zone.run((/**\n                         * @return {?}\n                         */\n                        function () {\n                            _this.drop.next({\n                                dropData: currentDragDropData,\n                            });\n                        }));\n                    }\n                }),\n            });\n        }));\n    };\n    /**\n     * @return {?}\n     */\n    DroppableDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this.currentDragSubscription) {\n            this.currentDragSubscription.unsubscribe();\n        }\n    };\n    DroppableDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[mwlDroppable]',\n                },] }\n    ];\n    /** @nocollapse */\n    DroppableDirective.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: DraggableHelper },\n        { type: NgZone },\n        { type: Renderer2 },\n        { type: DraggableScrollContainerDirective, decorators: [{ type: Optional }] }\n    ]; };\n    DroppableDirective.propDecorators = {\n        dragOverClass: [{ type: Input }],\n        dragActiveClass: [{ type: Input }],\n        dragEnter: [{ type: Output }],\n        dragLeave: [{ type: Output }],\n        dragOver: [{ type: Output }],\n        drop: [{ type: Output }]\n    };\n    return DroppableDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar DragAndDropModule = /** @class */ (function () {\n    function DragAndDropModule() {\n    }\n    DragAndDropModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                    exports: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                },] }\n    ];\n    return DragAndDropModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };\n"]}