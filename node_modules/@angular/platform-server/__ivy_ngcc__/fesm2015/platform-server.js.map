{"version":3,"sources":["C:/Users/MounaBouslah/Desktop/Seekmake/Main Project/material-dashboard-pro-angular-v2.4.1/node_modules/@angular/platform-server/fesm2015/platform-server.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8NC,sGAGC;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BD;;;0BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkVD,iIAGC;;;;;;;;;;;;;;;;kCAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4ED,6RAGC;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0ED,iIAGC;;;;;;;;;;;;;sEAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0eD,+GAGC;;;;;;;;;;;;;;;;kCAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiFD;;;;;;;;;;;;;;0BAYC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2DD;;;;;;;;;;;;;0BAYC","file":"platform-server.js","sourcesContent":["/**\n * @license Angular v9.0.1\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ɵsetRootDomAdapter, DOCUMENT, ɵgetDOM, ɵPLATFORM_SERVER_ID, PlatformLocation, ViewportScroller, ɵNullViewportScroller } from '@angular/common';\nimport { Injectable, Inject, Injector, InjectionToken, Optional, ViewEncapsulation, NgZone, PLATFORM_ID, PLATFORM_INITIALIZER, ɵALLOW_MULTIPLE_PLATFORMS, RendererFactory2, NgModule, Testability, ɵsetDocument, createPlatformFactory, platformCore, APP_ID, ApplicationRef, ɵisPromise, Version } from '@angular/core';\nimport { ɵBrowserDomAdapter, ɵflattenStyles, EventManager, ɵSharedStylesHost, ɵNAMESPACE_URIS, ɵshimContentAttribute, ɵshimHostAttribute, ɵTRANSITION_ID, EVENT_MANAGER_PLUGINS, BrowserModule, ɵescapeHtml, TransferState } from '@angular/platform-browser';\nimport { ɵAnimationEngine } from '@angular/animations/browser';\nimport { ɵHttpInterceptingHandler, XhrFactory, HttpHandler, HttpBackend, HttpClientModule } from '@angular/common/http';\nimport { ɵplatformCoreDynamic } from '@angular/platform-browser-dynamic';\nimport { ɵAnimationRendererFactory, NoopAnimationsModule } from '@angular/platform-browser/animations';\nimport { Observable, Subject } from 'rxjs';\nimport { parse } from 'url';\nimport { DomElementSchemaRegistry } from '@angular/compiler';\nimport { first } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/domino_adapter.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @type {?}\n */\nconst domino = require('domino');\n/**\n * @param {?} methodName\n * @return {?}\n */\nfunction _notImplemented(methodName) {\n    return new Error('This method is not implemented in DominoAdapter: ' + methodName);\n}\n/**\n * @return {?}\n */\nfunction setDomTypes() {\n    // Make all Domino types available as types in the global env.\n    Object.assign(global, domino.impl);\n    ((/** @type {?} */ (global)))['KeyboardEvent'] = domino.impl.Event;\n}\n/**\n * Parses a document string to a Document object.\n * @param {?} html\n * @param {?=} url\n * @return {?}\n */\nfunction parseDocument(html, url = '/') {\n    /** @type {?} */\n    let window = domino.createWindow(html, url);\n    /** @type {?} */\n    let doc = window.document;\n    return doc;\n}\n/**\n * Serializes a document to string.\n * @param {?} doc\n * @return {?}\n */\nfunction serializeDocument(doc) {\n    return ((/** @type {?} */ (doc))).serialize();\n}\n/**\n * DOM Adapter for the server platform based on https://github.com/fgnass/domino.\n */\nclass DominoAdapter extends ɵBrowserDomAdapter {\n    /**\n     * @return {?}\n     */\n    static makeCurrent() {\n        setDomTypes();\n        ɵsetRootDomAdapter(new DominoAdapter());\n    }\n    /**\n     * @param {?} error\n     * @return {?}\n     */\n    log(error) {\n        // tslint:disable-next-line:no-console\n        console.log(error);\n    }\n    /**\n     * @param {?} error\n     * @return {?}\n     */\n    logGroup(error) { console.error(error); }\n    /**\n     * @return {?}\n     */\n    logGroupEnd() { }\n    /**\n     * @return {?}\n     */\n    supportsDOMEvents() { return false; }\n    /**\n     * @return {?}\n     */\n    createHtmlDocument() {\n        return parseDocument('<html><head><title>fakeTitle</title></head><body></body></html>');\n    }\n    /**\n     * @return {?}\n     */\n    getDefaultDocument() {\n        if (!DominoAdapter.defaultDoc) {\n            DominoAdapter.defaultDoc = domino.createDocument();\n        }\n        return DominoAdapter.defaultDoc;\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    isElementNode(node) {\n        return node ? node.nodeType === DominoAdapter.defaultDoc.ELEMENT_NODE : false;\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    isShadowRoot(node) { return node.shadowRoot == node; }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @return {?}\n     */\n    getProperty(el, name) {\n        if (name === 'href') {\n            // Domino tries to resolve href-s which we do not want. Just return the\n            // attribute value.\n            return el.getAttribute('href');\n        }\n        else if (name === 'innerText') {\n            // Domino does not support innerText. Just map it to textContent.\n            return el.textContent;\n        }\n        return ((/** @type {?} */ (el)))[name];\n    }\n    /**\n     * @param {?} doc\n     * @param {?} target\n     * @return {?}\n     */\n    getGlobalEventTarget(doc, target) {\n        if (target === 'window') {\n            return doc.defaultView;\n        }\n        if (target === 'document') {\n            return doc;\n        }\n        if (target === 'body') {\n            return doc.body;\n        }\n        return null;\n    }\n    /**\n     * @param {?} doc\n     * @return {?}\n     */\n    getBaseHref(doc) {\n        /** @type {?} */\n        const base = (/** @type {?} */ (doc.documentElement)).querySelector('base');\n        /** @type {?} */\n        let href = '';\n        if (base) {\n            href = (/** @type {?} */ (base.getAttribute('href')));\n        }\n        // TODO(alxhub): Need relative path logic from BrowserDomAdapter here?\n        return href;\n    }\n    /**\n     * @param {?} el\n     * @param {?} evt\n     * @return {?}\n     */\n    dispatchEvent(el, evt) {\n        el.dispatchEvent(evt);\n        // Dispatch the event to the window also.\n        /** @type {?} */\n        const doc = el.ownerDocument || el;\n        /** @type {?} */\n        const win = ((/** @type {?} */ (doc))).defaultView;\n        if (win) {\n            win.dispatchEvent(evt);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    getHistory() { throw _notImplemented('getHistory'); }\n    /**\n     * @return {?}\n     */\n    getLocation() { throw _notImplemented('getLocation'); }\n    /**\n     * @return {?}\n     */\n    getUserAgent() { return 'Fake user agent'; }\n    /**\n     * @return {?}\n     */\n    performanceNow() { return Date.now(); }\n    /**\n     * @return {?}\n     */\n    supportsCookies() { return false; }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getCookie(name) { throw _notImplemented('getCookie'); }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    DominoAdapter.defaultDoc;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/platform_state.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Representation of the current platform state.\n *\n * \\@publicApi\n */\nclass PlatformState {\n    /**\n     * @param {?} _doc\n     */\n    constructor(_doc) {\n        this._doc = _doc;\n    }\n    /**\n     * Renders the current state of the platform to string.\n     * @return {?}\n     */\n    renderToString() { return serializeDocument(this._doc); }\n    /**\n     * Returns the current DOM state.\n     * @return {?}\n     */\n    getDocument() { return this._doc; }\n}\nPlatformState.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nPlatformState.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    PlatformState.prototype._doc;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/http.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @type {?} */\nconst xhr2 = require('xhr2');\nclass ServerXhr {\n    /**\n     * @return {?}\n     */\n    build() { return new xhr2.XMLHttpRequest(); }\n}\nServerXhr.decorators = [\n    { type: Injectable }\n];\n/**\n * @abstract\n * @template S, R\n */\nclass ZoneMacroTaskWrapper {\n    /**\n     * @param {?} request\n     * @return {?}\n     */\n    wrap(request) {\n        return new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            let task = (/** @type {?} */ (null));\n            /** @type {?} */\n            let scheduled = false;\n            /** @type {?} */\n            let sub = null;\n            /** @type {?} */\n            let savedResult = null;\n            /** @type {?} */\n            let savedError = null;\n            /** @type {?} */\n            const scheduleTask = (/**\n             * @param {?} _task\n             * @return {?}\n             */\n            (_task) => {\n                task = _task;\n                scheduled = true;\n                /** @type {?} */\n                const delegate = this.delegate(request);\n                sub = delegate.subscribe((/**\n                 * @param {?} res\n                 * @return {?}\n                 */\n                res => savedResult = res), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                err => {\n                    if (!scheduled) {\n                        throw new Error('An http observable was completed twice. This shouldn\\'t happen, please file a bug.');\n                    }\n                    savedError = err;\n                    scheduled = false;\n                    task.invoke();\n                }), (/**\n                 * @return {?}\n                 */\n                () => {\n                    if (!scheduled) {\n                        throw new Error('An http observable was completed twice. This shouldn\\'t happen, please file a bug.');\n                    }\n                    scheduled = false;\n                    task.invoke();\n                }));\n            });\n            /** @type {?} */\n            const cancelTask = (/**\n             * @param {?} _task\n             * @return {?}\n             */\n            (_task) => {\n                if (!scheduled) {\n                    return;\n                }\n                scheduled = false;\n                if (sub) {\n                    sub.unsubscribe();\n                    sub = null;\n                }\n            });\n            /** @type {?} */\n            const onComplete = (/**\n             * @return {?}\n             */\n            () => {\n                if (savedError !== null) {\n                    observer.error(savedError);\n                }\n                else {\n                    observer.next(savedResult);\n                    observer.complete();\n                }\n            });\n            // MockBackend for Http is synchronous, which means that if scheduleTask is by\n            // scheduleMacroTask, the request will hit MockBackend and the response will be\n            // sent, causing task.invoke() to be called.\n            /** @type {?} */\n            const _task = Zone.current.scheduleMacroTask('ZoneMacroTaskWrapper.subscribe', onComplete, {}, (/**\n             * @return {?}\n             */\n            () => null), cancelTask);\n            scheduleTask(_task);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                if (scheduled && task) {\n                    task.zone.cancelTask(task);\n                    scheduled = false;\n                }\n                if (sub) {\n                    sub.unsubscribe();\n                    sub = null;\n                }\n            });\n        }));\n    }\n}\nif (false) {\n    /**\n     * @abstract\n     * @protected\n     * @param {?} request\n     * @return {?}\n     */\n    ZoneMacroTaskWrapper.prototype.delegate = function (request) { };\n}\nclass ZoneClientBackend extends ZoneMacroTaskWrapper {\n    /**\n     * @param {?} backend\n     */\n    constructor(backend) {\n        super();\n        this.backend = backend;\n    }\n    /**\n     * @param {?} request\n     * @return {?}\n     */\n    handle(request) { return this.wrap(request); }\n    /**\n     * @protected\n     * @param {?} request\n     * @return {?}\n     */\n    delegate(request) {\n        return this.backend.handle(request);\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ZoneClientBackend.prototype.backend;\n}\n/**\n * @param {?} backend\n * @param {?} injector\n * @return {?}\n */\nfunction zoneWrappedInterceptingHandler(backend, injector) {\n    /** @type {?} */\n    const realBackend = new ɵHttpInterceptingHandler(backend, injector);\n    return new ZoneClientBackend(realBackend);\n}\n/** @type {?} */\nconst SERVER_HTTP_PROVIDERS = [\n    { provide: XhrFactory, useClass: ServerXhr }, {\n        provide: HttpHandler,\n        useFactory: zoneWrappedInterceptingHandler,\n        deps: [HttpBackend, Injector]\n    }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/tokens.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Config object passed to initialize the platform.\n *\n * \\@publicApi\n * @record\n */\nfunction PlatformConfig() { }\nif (false) {\n    /** @type {?|undefined} */\n    PlatformConfig.prototype.document;\n    /** @type {?|undefined} */\n    PlatformConfig.prototype.url;\n}\n/**\n * The DI token for setting the initial config for the platform.\n *\n * \\@publicApi\n * @type {?}\n */\nconst INITIAL_CONFIG = new InjectionToken('Server.INITIAL_CONFIG');\n/**\n * A function that will be executed when calling `renderModuleFactory` or `renderModule` just\n * before current platform state is rendered to string.\n *\n * \\@publicApi\n * @type {?}\n */\nconst BEFORE_APP_SERIALIZED = new InjectionToken('Server.RENDER_MODULE_HOOK');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/location.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} urlStr\n * @return {?}\n */\nfunction parseUrl(urlStr) {\n    /** @type {?} */\n    const parsedUrl = parse(urlStr);\n    return {\n        hostname: parsedUrl.hostname || '',\n        protocol: parsedUrl.protocol || '',\n        port: parsedUrl.port || '',\n        pathname: parsedUrl.pathname || '',\n        search: parsedUrl.search || '',\n        hash: parsedUrl.hash || '',\n    };\n}\n/**\n * Server-side implementation of URL state. Implements `pathname`, `search`, and `hash`\n * but not the state stack.\n */\nclass ServerPlatformLocation {\n    /**\n     * @param {?} _doc\n     * @param {?} _config\n     */\n    constructor(_doc, _config) {\n        this._doc = _doc;\n        this.href = '/';\n        this.hostname = '/';\n        this.protocol = '/';\n        this.port = '/';\n        this.pathname = '/';\n        this.search = '';\n        this.hash = '';\n        this._hashUpdate = new Subject();\n        /** @type {?} */\n        const config = (/** @type {?} */ (_config));\n        if (!!config && !!config.url) {\n            /** @type {?} */\n            const parsedUrl = parseUrl(config.url);\n            this.hostname = parsedUrl.hostname;\n            this.protocol = parsedUrl.protocol;\n            this.port = parsedUrl.port;\n            this.pathname = parsedUrl.pathname;\n            this.search = parsedUrl.search;\n            this.hash = parsedUrl.hash;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    getBaseHrefFromDOM() { return (/** @type {?} */ (ɵgetDOM().getBaseHref(this._doc))); }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    onPopState(fn) {\n        // No-op: a state stack is not implemented, so\n        // no events will ever come.\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    onHashChange(fn) { this._hashUpdate.subscribe(fn); }\n    /**\n     * @return {?}\n     */\n    get url() { return `${this.pathname}${this.search}${this.hash}`; }\n    /**\n     * @private\n     * @param {?} value\n     * @param {?} oldUrl\n     * @return {?}\n     */\n    setHash(value, oldUrl) {\n        if (this.hash === value) {\n            // Don't fire events if the hash has not changed.\n            return;\n        }\n        ((/** @type {?} */ (this))).hash = value;\n        /** @type {?} */\n        const newUrl = this.url;\n        scheduleMicroTask((/**\n         * @return {?}\n         */\n        () => this._hashUpdate.next((/** @type {?} */ ({\n            type: 'hashchange', state: null, oldUrl, newUrl\n        })))));\n    }\n    /**\n     * @param {?} state\n     * @param {?} title\n     * @param {?} newUrl\n     * @return {?}\n     */\n    replaceState(state, title, newUrl) {\n        /** @type {?} */\n        const oldUrl = this.url;\n        /** @type {?} */\n        const parsedUrl = parseUrl(newUrl);\n        ((/** @type {?} */ (this))).pathname = parsedUrl.pathname;\n        ((/** @type {?} */ (this))).search = parsedUrl.search;\n        this.setHash(parsedUrl.hash, oldUrl);\n    }\n    /**\n     * @param {?} state\n     * @param {?} title\n     * @param {?} newUrl\n     * @return {?}\n     */\n    pushState(state, title, newUrl) {\n        this.replaceState(state, title, newUrl);\n    }\n    /**\n     * @return {?}\n     */\n    forward() { throw new Error('Not implemented'); }\n    /**\n     * @return {?}\n     */\n    back() { throw new Error('Not implemented'); }\n    // History API isn't available on server, therefore return undefined\n    /**\n     * @return {?}\n     */\n    getState() { return undefined; }\n}\nServerPlatformLocation.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nServerPlatformLocation.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_CONFIG,] }] }\n];\nif (false) {\n    /** @type {?} */\n    ServerPlatformLocation.prototype.href;\n    /** @type {?} */\n    ServerPlatformLocation.prototype.hostname;\n    /** @type {?} */\n    ServerPlatformLocation.prototype.protocol;\n    /** @type {?} */\n    ServerPlatformLocation.prototype.port;\n    /** @type {?} */\n    ServerPlatformLocation.prototype.pathname;\n    /** @type {?} */\n    ServerPlatformLocation.prototype.search;\n    /** @type {?} */\n    ServerPlatformLocation.prototype.hash;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerPlatformLocation.prototype._hashUpdate;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerPlatformLocation.prototype._doc;\n}\n/**\n * @param {?} fn\n * @return {?}\n */\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/server_events.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ServerEventManagerPlugin /* extends EventManagerPlugin which is private */ {\n    /**\n     * @param {?} doc\n     */\n    constructor(doc) {\n        this.doc = doc;\n    }\n    // Handle all events on the server.\n    /**\n     * @param {?} eventName\n     * @return {?}\n     */\n    supports(eventName) { return true; }\n    /**\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} handler\n     * @return {?}\n     */\n    addEventListener(element, eventName, handler) {\n        return ɵgetDOM().onAndCancel(element, eventName, handler);\n    }\n    /**\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} handler\n     * @return {?}\n     */\n    addGlobalEventListener(element, eventName, handler) {\n        /** @type {?} */\n        const target = ɵgetDOM().getGlobalEventTarget(this.doc, element);\n        if (!target) {\n            throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n        }\n        return this.addEventListener(target, eventName, handler);\n    }\n}\nServerEventManagerPlugin.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nServerEventManagerPlugin.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerEventManagerPlugin.prototype.doc;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/server_renderer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst EMPTY_ARRAY = [];\n/** @type {?} */\nconst DEFAULT_SCHEMA = new DomElementSchemaRegistry();\nclass ServerRendererFactory2 {\n    /**\n     * @param {?} eventManager\n     * @param {?} ngZone\n     * @param {?} document\n     * @param {?} sharedStylesHost\n     */\n    constructor(eventManager, ngZone, document, sharedStylesHost) {\n        this.eventManager = eventManager;\n        this.ngZone = ngZone;\n        this.document = document;\n        this.sharedStylesHost = sharedStylesHost;\n        this.rendererByCompId = new Map();\n        this.schema = DEFAULT_SCHEMA;\n        this.defaultRenderer = new DefaultServerRenderer2(eventManager, document, ngZone, this.schema);\n    }\n    /**\n     * @param {?} element\n     * @param {?} type\n     * @return {?}\n     */\n    createRenderer(element, type) {\n        if (!element || !type) {\n            return this.defaultRenderer;\n        }\n        switch (type.encapsulation) {\n            case ViewEncapsulation.Native:\n            case ViewEncapsulation.Emulated: {\n                /** @type {?} */\n                let renderer = this.rendererByCompId.get(type.id);\n                if (!renderer) {\n                    renderer = new EmulatedEncapsulationServerRenderer2(this.eventManager, this.document, this.ngZone, this.sharedStylesHost, this.schema, type);\n                    this.rendererByCompId.set(type.id, renderer);\n                }\n                ((/** @type {?} */ (renderer))).applyToHost(element);\n                return renderer;\n            }\n            default: {\n                if (!this.rendererByCompId.has(type.id)) {\n                    /** @type {?} */\n                    const styles = ɵflattenStyles(type.id, type.styles, []);\n                    this.sharedStylesHost.addStyles(styles);\n                    this.rendererByCompId.set(type.id, this.defaultRenderer);\n                }\n                return this.defaultRenderer;\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    begin() { }\n    /**\n     * @return {?}\n     */\n    end() { }\n}\nServerRendererFactory2.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nServerRendererFactory2.ctorParameters = () => [\n    { type: EventManager },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: ɵSharedStylesHost }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerRendererFactory2.prototype.rendererByCompId;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerRendererFactory2.prototype.defaultRenderer;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerRendererFactory2.prototype.schema;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerRendererFactory2.prototype.eventManager;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerRendererFactory2.prototype.ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerRendererFactory2.prototype.document;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerRendererFactory2.prototype.sharedStylesHost;\n}\nclass DefaultServerRenderer2 {\n    /**\n     * @param {?} eventManager\n     * @param {?} document\n     * @param {?} ngZone\n     * @param {?} schema\n     */\n    constructor(eventManager, document, ngZone, schema) {\n        this.eventManager = eventManager;\n        this.document = document;\n        this.ngZone = ngZone;\n        this.schema = schema;\n        this.data = Object.create(null);\n    }\n    /**\n     * @return {?}\n     */\n    destroy() { }\n    /**\n     * @param {?} name\n     * @param {?=} namespace\n     * @param {?=} debugInfo\n     * @return {?}\n     */\n    createElement(name, namespace, debugInfo) {\n        if (namespace) {\n            /** @type {?} */\n            const doc = this.document || ɵgetDOM().getDefaultDocument();\n            // TODO(FW-811): Ivy may cause issues here because it's passing around\n            // full URIs for namespaces, therefore this lookup will fail.\n            return doc.createElementNS(ɵNAMESPACE_URIS[namespace], name);\n        }\n        return ɵgetDOM().createElement(name, this.document);\n    }\n    /**\n     * @param {?} value\n     * @param {?=} debugInfo\n     * @return {?}\n     */\n    createComment(value, debugInfo) {\n        return ɵgetDOM().getDefaultDocument().createComment(value);\n    }\n    /**\n     * @param {?} value\n     * @param {?=} debugInfo\n     * @return {?}\n     */\n    createText(value, debugInfo) {\n        /** @type {?} */\n        const doc = ɵgetDOM().getDefaultDocument();\n        return doc.createTextNode(value);\n    }\n    /**\n     * @param {?} parent\n     * @param {?} newChild\n     * @return {?}\n     */\n    appendChild(parent, newChild) { parent.appendChild(newChild); }\n    /**\n     * @param {?} parent\n     * @param {?} newChild\n     * @param {?} refChild\n     * @return {?}\n     */\n    insertBefore(parent, newChild, refChild) {\n        if (parent) {\n            parent.insertBefore(newChild, refChild);\n        }\n    }\n    /**\n     * @param {?} parent\n     * @param {?} oldChild\n     * @return {?}\n     */\n    removeChild(parent, oldChild) {\n        if (parent) {\n            parent.removeChild(oldChild);\n        }\n    }\n    /**\n     * @param {?} selectorOrNode\n     * @param {?=} debugInfo\n     * @return {?}\n     */\n    selectRootElement(selectorOrNode, debugInfo) {\n        /** @type {?} */\n        let el;\n        if (typeof selectorOrNode === 'string') {\n            el = this.document.querySelector(selectorOrNode);\n            if (!el) {\n                throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n            }\n        }\n        else {\n            el = selectorOrNode;\n        }\n        while (el.firstChild) {\n            el.removeChild(el.firstChild);\n        }\n        return el;\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    parentNode(node) { return node.parentNode; }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    nextSibling(node) { return node.nextSibling; }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} namespace\n     * @return {?}\n     */\n    setAttribute(el, name, value, namespace) {\n        if (namespace) {\n            // TODO(FW-811): Ivy may cause issues here because it's passing around\n            // full URIs for namespaces, therefore this lookup will fail.\n            el.setAttributeNS(ɵNAMESPACE_URIS[namespace], namespace + ':' + name, value);\n        }\n        else {\n            el.setAttribute(name, value);\n        }\n    }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @param {?=} namespace\n     * @return {?}\n     */\n    removeAttribute(el, name, namespace) {\n        if (namespace) {\n            // TODO(FW-811): Ivy may cause issues here because it's passing around\n            // full URIs for namespaces, therefore this lookup will fail.\n            el.removeAttributeNS(ɵNAMESPACE_URIS[namespace], name);\n        }\n        else {\n            el.removeAttribute(name);\n        }\n    }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @return {?}\n     */\n    addClass(el, name) { el.classList.add(name); }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @return {?}\n     */\n    removeClass(el, name) { el.classList.remove(name); }\n    /**\n     * @param {?} el\n     * @param {?} style\n     * @param {?} value\n     * @param {?} flags\n     * @return {?}\n     */\n    setStyle(el, style, value, flags) {\n        style = style.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n        /** @type {?} */\n        const styleMap = _readStyleAttribute(el);\n        styleMap[style] = value == null ? '' : value;\n        _writeStyleAttribute(el, styleMap);\n    }\n    /**\n     * @param {?} el\n     * @param {?} style\n     * @param {?} flags\n     * @return {?}\n     */\n    removeStyle(el, style, flags) {\n        // IE requires '' instead of null\n        // see https://github.com/angular/angular/issues/7916\n        this.setStyle(el, style, '', flags);\n    }\n    // The value was validated already as a property binding, against the property name.\n    // To know this value is safe to use as an attribute, the security context of the\n    // attribute with the given name is checked against that security context of the\n    // property.\n    /**\n     * @private\n     * @param {?} tagName\n     * @param {?} propertyName\n     * @return {?}\n     */\n    _isSafeToReflectProperty(tagName, propertyName) {\n        return this.schema.securityContext(tagName, propertyName, true) ===\n            this.schema.securityContext(tagName, propertyName, false);\n    }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @param {?} value\n     * @return {?}\n     */\n    setProperty(el, name, value) {\n        checkNoSyntheticProp(name, 'property');\n        if (name === 'innerText') {\n            // Domino does not support innerText. Just map it to textContent.\n            el.textContent = value;\n        }\n        ((/** @type {?} */ (el)))[name] = value;\n        // Mirror property values for known HTML element properties in the attributes.\n        // Skip `innerhtml` which is conservatively marked as an attribute for security\n        // purposes but is not actually an attribute.\n        /** @type {?} */\n        const tagName = ((/** @type {?} */ (el.tagName))).toLowerCase();\n        if (value != null && (typeof value === 'number' || typeof value == 'string') &&\n            name.toLowerCase() !== 'innerhtml' && this.schema.hasElement(tagName, EMPTY_ARRAY) &&\n            this.schema.hasProperty(tagName, name, EMPTY_ARRAY) &&\n            this._isSafeToReflectProperty(tagName, name)) {\n            this.setAttribute(el, name, value.toString());\n        }\n    }\n    /**\n     * @param {?} node\n     * @param {?} value\n     * @return {?}\n     */\n    setValue(node, value) { node.textContent = value; }\n    /**\n     * @param {?} target\n     * @param {?} eventName\n     * @param {?} callback\n     * @return {?}\n     */\n    listen(target, eventName, callback) {\n        checkNoSyntheticProp(eventName, 'listener');\n        if (typeof target === 'string') {\n            return (/** @type {?} */ (this.eventManager.addGlobalEventListener(target, eventName, this.decoratePreventDefault(callback))));\n        }\n        return (/** @type {?} */ ((/** @type {?} */ (this.eventManager.addEventListener(target, eventName, this.decoratePreventDefault(callback))))));\n    }\n    /**\n     * @private\n     * @param {?} eventHandler\n     * @return {?}\n     */\n    decoratePreventDefault(eventHandler) {\n        return (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            // Ivy uses `Function` as a special token that allows us to unwrap the function\n            // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n            if (event === Function) {\n                return eventHandler;\n            }\n            // Run the event handler inside the ngZone because event handlers are not patched\n            // by Zone on the server. This is required only for tests.\n            /** @type {?} */\n            const allowDefaultBehavior = this.ngZone.runGuarded((/**\n             * @return {?}\n             */\n            () => eventHandler(event)));\n            if (allowDefaultBehavior === false) {\n                event.preventDefault();\n                event.returnValue = false;\n            }\n            return undefined;\n        });\n    }\n}\nif (false) {\n    /** @type {?} */\n    DefaultServerRenderer2.prototype.data;\n    /** @type {?} */\n    DefaultServerRenderer2.prototype.destroyNode;\n    /**\n     * @type {?}\n     * @private\n     */\n    DefaultServerRenderer2.prototype.eventManager;\n    /**\n     * @type {?}\n     * @protected\n     */\n    DefaultServerRenderer2.prototype.document;\n    /**\n     * @type {?}\n     * @private\n     */\n    DefaultServerRenderer2.prototype.ngZone;\n    /**\n     * @type {?}\n     * @private\n     */\n    DefaultServerRenderer2.prototype.schema;\n}\n/** @type {?} */\nconst AT_CHARCODE = '@'.charCodeAt(0);\n/**\n * @param {?} name\n * @param {?} nameKind\n * @return {?}\n */\nfunction checkNoSyntheticProp(name, nameKind) {\n    if (name.charCodeAt(0) === AT_CHARCODE) {\n        throw new Error(`Found the synthetic ${nameKind} ${name}. Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.`);\n    }\n}\nclass EmulatedEncapsulationServerRenderer2 extends DefaultServerRenderer2 {\n    /**\n     * @param {?} eventManager\n     * @param {?} document\n     * @param {?} ngZone\n     * @param {?} sharedStylesHost\n     * @param {?} schema\n     * @param {?} component\n     */\n    constructor(eventManager, document, ngZone, sharedStylesHost, schema, component) {\n        super(eventManager, document, ngZone, schema);\n        this.component = component;\n        // Add a 's' prefix to style attributes to indicate server.\n        /** @type {?} */\n        const componentId = 's' + component.id;\n        /** @type {?} */\n        const styles = ɵflattenStyles(componentId, component.styles, []);\n        sharedStylesHost.addStyles(styles);\n        this.contentAttr = ɵshimContentAttribute(componentId);\n        this.hostAttr = ɵshimHostAttribute(componentId);\n    }\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    applyToHost(element) { super.setAttribute(element, this.hostAttr, ''); }\n    /**\n     * @param {?} parent\n     * @param {?} name\n     * @return {?}\n     */\n    createElement(parent, name) {\n        /** @type {?} */\n        const el = super.createElement(parent, name, this.document);\n        super.setAttribute(el, this.contentAttr, '');\n        return el;\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    EmulatedEncapsulationServerRenderer2.prototype.contentAttr;\n    /**\n     * @type {?}\n     * @private\n     */\n    EmulatedEncapsulationServerRenderer2.prototype.hostAttr;\n    /**\n     * @type {?}\n     * @private\n     */\n    EmulatedEncapsulationServerRenderer2.prototype.component;\n}\n/**\n * @param {?} element\n * @return {?}\n */\nfunction _readStyleAttribute(element) {\n    /** @type {?} */\n    const styleMap = {};\n    /** @type {?} */\n    const styleAttribute = element.getAttribute('style');\n    if (styleAttribute) {\n        /** @type {?} */\n        const styleList = styleAttribute.split(/;+/g);\n        for (let i = 0; i < styleList.length; i++) {\n            /** @type {?} */\n            const style = styleList[i].trim();\n            if (style.length > 0) {\n                /** @type {?} */\n                const colonIndex = style.indexOf(':');\n                if (colonIndex === -1) {\n                    throw new Error(`Invalid CSS style: ${style}`);\n                }\n                /** @type {?} */\n                const name = style.substr(0, colonIndex).trim();\n                styleMap[name] = style.substr(colonIndex + 1).trim();\n            }\n        }\n    }\n    return styleMap;\n}\n/**\n * @param {?} element\n * @param {?} styleMap\n * @return {?}\n */\nfunction _writeStyleAttribute(element, styleMap) {\n    /** @type {?} */\n    let styleAttrValue = '';\n    for (const key in styleMap) {\n        /** @type {?} */\n        const newValue = styleMap[key];\n        if (newValue != null) {\n            styleAttrValue += key + ':' + styleMap[key] + ';';\n        }\n    }\n    element.setAttribute('style', styleAttrValue);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/styles_host.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ServerStylesHost extends ɵSharedStylesHost {\n    /**\n     * @param {?} doc\n     * @param {?} transitionId\n     */\n    constructor(doc, transitionId) {\n        super();\n        this.doc = doc;\n        this.transitionId = transitionId;\n        this.head = null;\n        this.head = doc.getElementsByTagName('head')[0];\n    }\n    /**\n     * @private\n     * @param {?} style\n     * @return {?}\n     */\n    _addStyle(style) {\n        /** @type {?} */\n        let adapter = ɵgetDOM();\n        /** @type {?} */\n        const el = adapter.createElement('style');\n        el.textContent = style;\n        if (!!this.transitionId) {\n            el.setAttribute('ng-transition', this.transitionId);\n        }\n        this.head.appendChild(el);\n    }\n    /**\n     * @param {?} additions\n     * @return {?}\n     */\n    onStylesAdded(additions) { additions.forEach((/**\n     * @param {?} style\n     * @return {?}\n     */\n    style => this._addStyle(style))); }\n}\nServerStylesHost.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nServerStylesHost.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ɵTRANSITION_ID,] }] }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerStylesHost.prototype.head;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerStylesHost.prototype.doc;\n    /**\n     * @type {?}\n     * @private\n     */\n    ServerStylesHost.prototype.transitionId;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/server.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} feature\n * @return {?}\n */\nfunction notSupported(feature) {\n    throw new Error(`platform-server does not support '${feature}'.`);\n}\n/** @type {?} */\nconst INTERNAL_SERVER_PLATFORM_PROVIDERS = [\n    { provide: DOCUMENT, useFactory: _document, deps: [Injector] },\n    { provide: PLATFORM_ID, useValue: ɵPLATFORM_SERVER_ID },\n    { provide: PLATFORM_INITIALIZER, useFactory: initDominoAdapter, multi: true, deps: [Injector] }, {\n        provide: PlatformLocation,\n        useClass: ServerPlatformLocation,\n        deps: [DOCUMENT, [Optional, INITIAL_CONFIG]]\n    },\n    { provide: PlatformState, deps: [DOCUMENT] },\n    // Add special provider that allows multiple instances of platformServer* to be created.\n    { provide: ɵALLOW_MULTIPLE_PLATFORMS, useValue: true }\n];\n/**\n * @param {?} injector\n * @return {?}\n */\nfunction initDominoAdapter(injector) {\n    return (/**\n     * @return {?}\n     */\n    () => { DominoAdapter.makeCurrent(); });\n}\n/**\n * @param {?} renderer\n * @param {?} engine\n * @param {?} zone\n * @return {?}\n */\nfunction instantiateServerRendererFactory(renderer, engine, zone) {\n    return new ɵAnimationRendererFactory(renderer, engine, zone);\n}\n/** @type {?} */\nconst SERVER_RENDER_PROVIDERS = [\n    ServerRendererFactory2,\n    {\n        provide: RendererFactory2,\n        useFactory: instantiateServerRendererFactory,\n        deps: [ServerRendererFactory2, ɵAnimationEngine, NgZone]\n    },\n    ServerStylesHost,\n    { provide: ɵSharedStylesHost, useExisting: ServerStylesHost },\n    { provide: EVENT_MANAGER_PLUGINS, multi: true, useClass: ServerEventManagerPlugin },\n];\n/**\n * The ng module for the server.\n *\n * \\@publicApi\n */\nclass ServerModule {\n}\nServerModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [BrowserModule],\n                imports: [HttpClientModule, NoopAnimationsModule],\n                providers: [\n                    SERVER_RENDER_PROVIDERS,\n                    SERVER_HTTP_PROVIDERS,\n                    { provide: Testability, useValue: null },\n                    { provide: ViewportScroller, useClass: ɵNullViewportScroller },\n                ],\n            },] }\n];\n/**\n * @param {?} injector\n * @return {?}\n */\nfunction _document(injector) {\n    /** @type {?} */\n    let config = injector.get(INITIAL_CONFIG, null);\n    /** @type {?} */\n    const document = config && config.document ? parseDocument(config.document, config.url) :\n        ɵgetDOM().createHtmlDocument();\n    // Tell ivy about the global document\n    ɵsetDocument(document);\n    return document;\n}\n/**\n * \\@publicApi\n * @type {?}\n */\nconst platformServer = createPlatformFactory(platformCore, 'server', INTERNAL_SERVER_PLATFORM_PROVIDERS);\n/**\n * The server platform that supports the runtime compiler.\n *\n * \\@publicApi\n * @type {?}\n */\nconst platformDynamicServer = createPlatformFactory(ɵplatformCoreDynamic, 'serverDynamic', INTERNAL_SERVER_PLATFORM_PROVIDERS);\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/transfer_state.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} doc\n * @param {?} appId\n * @param {?} transferStore\n * @return {?}\n */\nfunction serializeTransferStateFactory(doc, appId, transferStore) {\n    return (/**\n     * @return {?}\n     */\n    () => {\n        /** @type {?} */\n        const script = doc.createElement('script');\n        script.id = appId + '-state';\n        script.setAttribute('type', 'application/json');\n        script.textContent = ɵescapeHtml(transferStore.toJson());\n        doc.body.appendChild(script);\n    });\n}\n/**\n * NgModule to install on the server side while using the `TransferState` to transfer state from\n * server to client.\n *\n * \\@publicApi\n */\nclass ServerTransferStateModule {\n}\nServerTransferStateModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [\n                    TransferState, {\n                        provide: BEFORE_APP_SERIALIZED,\n                        useFactory: serializeTransferStateFactory,\n                        deps: [DOCUMENT, APP_ID, TransferState],\n                        multi: true,\n                    }\n                ]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction PlatformOptions() { }\nif (false) {\n    /** @type {?|undefined} */\n    PlatformOptions.prototype.document;\n    /** @type {?|undefined} */\n    PlatformOptions.prototype.url;\n    /** @type {?|undefined} */\n    PlatformOptions.prototype.extraProviders;\n}\n/**\n * @param {?} platformFactory\n * @param {?} options\n * @return {?}\n */\nfunction _getPlatform(platformFactory, options) {\n    /** @type {?} */\n    const extraProviders = options.extraProviders ? options.extraProviders : [];\n    return platformFactory([\n        { provide: INITIAL_CONFIG, useValue: { document: options.document, url: options.url } },\n        extraProviders\n    ]);\n}\n/**\n * @template T\n * @param {?} platform\n * @param {?} moduleRefPromise\n * @return {?}\n */\nfunction _render(platform, moduleRefPromise) {\n    return moduleRefPromise.then((/**\n     * @param {?} moduleRef\n     * @return {?}\n     */\n    (moduleRef) => {\n        /** @type {?} */\n        const transitionId = moduleRef.injector.get(ɵTRANSITION_ID, null);\n        if (!transitionId) {\n            throw new Error(`renderModule[Factory]() requires the use of BrowserModule.withServerTransition() to ensure\nthe server-rendered app can be properly bootstrapped into a client app.`);\n        }\n        /** @type {?} */\n        const applicationRef = moduleRef.injector.get(ApplicationRef);\n        return applicationRef.isStable.pipe((first((/**\n         * @param {?} isStable\n         * @return {?}\n         */\n        (isStable) => isStable))))\n            .toPromise()\n            .then((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const platformState = platform.injector.get(PlatformState);\n            /** @type {?} */\n            const asyncPromises = [];\n            // Run any BEFORE_APP_SERIALIZED callbacks just before rendering to string.\n            /** @type {?} */\n            const callbacks = moduleRef.injector.get(BEFORE_APP_SERIALIZED, null);\n            if (callbacks) {\n                for (const callback of callbacks) {\n                    try {\n                        /** @type {?} */\n                        const callbackResult = callback();\n                        if (ɵisPromise(callbackResult)) {\n                            // TODO: in TS3.7, callbackResult is void.\n                            asyncPromises.push((/** @type {?} */ (callbackResult)));\n                        }\n                    }\n                    catch (e) {\n                        // Ignore exceptions.\n                        console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);\n                    }\n                }\n            }\n            /** @type {?} */\n            const complete = (/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const output = platformState.renderToString();\n                platform.destroy();\n                return output;\n            });\n            if (asyncPromises.length === 0) {\n                return complete();\n            }\n            return Promise\n                .all(asyncPromises.map((/**\n             * @param {?} asyncPromise\n             * @return {?}\n             */\n            asyncPromise => {\n                return asyncPromise.catch((/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                e => { console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e); }));\n            })))\n                .then(complete);\n        }));\n    }));\n}\n/**\n * Renders a Module to string.\n *\n * `document` is the full document HTML of the page to render, as a string.\n * `url` is the URL for the current render request.\n * `extraProviders` are the platform level providers for the current render request.\n *\n * Do not use this in a production server environment. Use pre-compiled {\\@link NgModuleFactory} with\n * {\\@link renderModuleFactory} instead.\n *\n * \\@publicApi\n * @template T\n * @param {?} module\n * @param {?} options\n * @return {?}\n */\nfunction renderModule(module, options) {\n    /** @type {?} */\n    const platform = _getPlatform(platformDynamicServer, options);\n    return _render(platform, platform.bootstrapModule(module));\n}\n/**\n * Renders a {\\@link NgModuleFactory} to string.\n *\n * `document` is the full document HTML of the page to render, as a string.\n * `url` is the URL for the current render request.\n * `extraProviders` are the platform level providers for the current render request.\n *\n * \\@publicApi\n * @template T\n * @param {?} moduleFactory\n * @param {?} options\n * @return {?}\n */\nfunction renderModuleFactory(moduleFactory, options) {\n    /** @type {?} */\n    const platform = _getPlatform(platformServer, options);\n    return _render(platform, platform.bootstrapModuleFactory(moduleFactory));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/private_export.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/version.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@publicApi\n * @type {?}\n */\nconst VERSION = new Version('9.0.1');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/src/platform-server.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-server/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BEFORE_APP_SERIALIZED, INITIAL_CONFIG, PlatformState, ServerModule, ServerTransferStateModule, VERSION, platformDynamicServer, platformServer, renderModule, renderModuleFactory, INTERNAL_SERVER_PLATFORM_PROVIDERS as ɵINTERNAL_SERVER_PLATFORM_PROVIDERS, SERVER_RENDER_PROVIDERS as ɵSERVER_RENDER_PROVIDERS, ServerRendererFactory2 as ɵServerRendererFactory2, instantiateServerRendererFactory as ɵangular_packages_platform_server_platform_server_a, serializeTransferStateFactory as ɵangular_packages_platform_server_platform_server_b, ServerStylesHost as ɵangular_packages_platform_server_platform_server_c, ServerEventManagerPlugin as ɵangular_packages_platform_server_platform_server_d, ServerXhr as ɵangular_packages_platform_server_platform_server_e, zoneWrappedInterceptingHandler as ɵangular_packages_platform_server_platform_server_f, SERVER_HTTP_PROVIDERS as ɵangular_packages_platform_server_platform_server_g };\n"]}