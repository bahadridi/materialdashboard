{"version":3,"file":"focus-monitor.d.ts","sources":["C:/Users/MounaBouslah/Desktop/Seekmake/Main Project/material-dashboard-pro-angular-v2.4.1/node_modules/@angular/cdk/a11y/focus-monitor/focus-monitor.d.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Platform } from '@angular/cdk/platform';\nimport { ElementRef, EventEmitter, NgZone, OnDestroy } from '@angular/core';\nimport { Observable } from 'rxjs';\nexport declare const TOUCH_BUFFER_MS = 650;\nexport declare type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\n/**\n * Corresponds to the options that can be passed to the native `focus` event.\n * via https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n */\nexport interface FocusOptions {\n    /** Whether the browser should scroll to the element when it is focused. */\n    preventScroll?: boolean;\n}\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nexport declare class FocusMonitor implements OnDestroy {\n    private _ngZone;\n    private _platform;\n    /** The focus origin that the next focus event is a result of. */\n    private _origin;\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n    private _lastFocusOrigin;\n    /** Whether the window has just been focused. */\n    private _windowFocused;\n    /** The target of the last touch event. */\n    private _lastTouchTarget;\n    /** The timeout id of the touch timeout, used to cancel timeout later. */\n    private _touchTimeoutId;\n    /** The timeout id of the window focus timeout. */\n    private _windowFocusTimeoutId;\n    /** The timeout id of the origin clearing timeout. */\n    private _originTimeoutId;\n    /** Map of elements being monitored to their info. */\n    private _elementInfo;\n    /** The number of elements currently being monitored. */\n    private _monitoredElementCount;\n    /**\n     * Event listener for `keydown` events on the document.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    private _documentKeydownListener;\n    /**\n     * Event listener for `mousedown` events on the document.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    private _documentMousedownListener;\n    /**\n     * Event listener for `touchstart` events on the document.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    private _documentTouchstartListener;\n    /**\n     * Event listener for `focus` events on the window.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    private _windowFocusListener;\n    constructor(_ngZone: NgZone, _platform: Platform);\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    monitor(element: HTMLElement, checkChildren?: boolean): Observable<FocusOrigin>;\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    monitor(element: ElementRef<HTMLElement>, checkChildren?: boolean): Observable<FocusOrigin>;\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: HTMLElement): void;\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: ElementRef<HTMLElement>): void;\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element Element to focus.\n     * @param origin Focus origin.\n     * @param options Options that can be used to configure the focus behavior.\n     */\n    focusVia(element: HTMLElement, origin: FocusOrigin, options?: FocusOptions): void;\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element Element to focus.\n     * @param origin Focus origin.\n     * @param options Options that can be used to configure the focus behavior.\n     */\n    focusVia(element: ElementRef<HTMLElement>, origin: FocusOrigin, options?: FocusOptions): void;\n    ngOnDestroy(): void;\n    private _toggleClass;\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    private _setClasses;\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param origin The origin to set.\n     */\n    private _setOriginForCurrentEventQueue;\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param event The focus event to check.\n     * @returns Whether the event was caused by a touch.\n     */\n    private _wasCausedByTouch;\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    private _onFocus;\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event: FocusEvent, element: HTMLElement): void;\n    private _emitOrigin;\n    private _incrementMonitoredElementCount;\n    private _decrementMonitoredElementCount;\n}\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nexport declare class CdkMonitorFocus implements OnDestroy {\n    private _elementRef;\n    private _focusMonitor;\n    private _monitorSubscription;\n    cdkFocusChange: EventEmitter<FocusOrigin>;\n    constructor(_elementRef: ElementRef<HTMLElement>, _focusMonitor: FocusMonitor);\n    ngOnDestroy(): void;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+HA;;;;;;;;;;;;;;;;;;;;;AAiBA;"}