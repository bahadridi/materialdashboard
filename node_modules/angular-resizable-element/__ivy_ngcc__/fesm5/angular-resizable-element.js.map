{"version":3,"sources":["C:/Users/MounaBouslah/Desktop/Seekmake/Main Project/material-dashboard-pro-angular-v2.4.1/node_modules/angular-resizable-element/fesm5/angular-resizable-element.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAymBM,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA4PA,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;KAUD;;;;;;;;;;;;gDAMC","file":"angular-resizable-element.js","sourcesContent":["import { __assign, __read } from 'tslib';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, Observable, merge, EMPTY } from 'rxjs';\nimport { map, mergeMap, takeUntil, filter, pairwise, take, share, auditTime, switchMap, startWith, tap } from 'rxjs/operators';\nimport { Directive, Renderer2, ElementRef, Output, Input, EventEmitter, NgZone, Inject, PLATFORM_ID, HostListener, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} value1\n * @param {?} value2\n * @param {?=} precision\n * @return {?}\n */\nfunction isNumberCloseTo(value1, value2, precision) {\n    if (precision === void 0) { precision = 3; }\n    /** @type {?} */\n    var diff = Math.abs(value1 - value2);\n    return diff < precision;\n}\n/**\n * @param {?} startingRect\n * @param {?} edges\n * @param {?} clientX\n * @param {?} clientY\n * @return {?}\n */\nfunction getNewBoundingRectangle(startingRect, edges, clientX, clientY) {\n    /** @type {?} */\n    var newBoundingRect = {\n        top: startingRect.top,\n        bottom: startingRect.bottom,\n        left: startingRect.left,\n        right: startingRect.right\n    };\n    if (edges.top) {\n        newBoundingRect.top += clientY;\n    }\n    if (edges.bottom) {\n        newBoundingRect.bottom += clientY;\n    }\n    if (edges.left) {\n        newBoundingRect.left += clientX;\n    }\n    if (edges.right) {\n        newBoundingRect.right += clientX;\n    }\n    newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;\n    newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;\n    return newBoundingRect;\n}\n/**\n * @param {?} element\n * @param {?} ghostElementPositioning\n * @return {?}\n */\nfunction getElementRect(element, ghostElementPositioning) {\n    /** @type {?} */\n    var translateX = 0;\n    /** @type {?} */\n    var translateY = 0;\n    /** @type {?} */\n    var style = element.nativeElement.style;\n    /** @type {?} */\n    var transformProperties = [\n        'transform',\n        '-ms-transform',\n        '-moz-transform',\n        '-o-transform'\n    ];\n    /** @type {?} */\n    var transform = transformProperties\n        .map(function (property) { return style[property]; })\n        .find(function (value) { return !!value; });\n    if (transform && transform.includes('translate')) {\n        translateX = transform.replace(/.*translate3?d?\\(([0-9]*)px, ([0-9]*)px.*/, '$1');\n        translateY = transform.replace(/.*translate3?d?\\(([0-9]*)px, ([0-9]*)px.*/, '$2');\n    }\n    if (ghostElementPositioning === 'absolute') {\n        return {\n            height: element.nativeElement.offsetHeight,\n            width: element.nativeElement.offsetWidth,\n            top: element.nativeElement.offsetTop - translateY,\n            bottom: element.nativeElement.offsetHeight +\n                element.nativeElement.offsetTop -\n                translateY,\n            left: element.nativeElement.offsetLeft - translateX,\n            right: element.nativeElement.offsetWidth +\n                element.nativeElement.offsetLeft -\n                translateX\n        };\n    }\n    else {\n        /** @type {?} */\n        var boundingRect = element.nativeElement.getBoundingClientRect();\n        return {\n            height: boundingRect.height,\n            width: boundingRect.width,\n            top: boundingRect.top - translateY,\n            bottom: boundingRect.bottom - translateY,\n            left: boundingRect.left - translateX,\n            right: boundingRect.right - translateX,\n            scrollTop: element.nativeElement.scrollTop,\n            scrollLeft: element.nativeElement.scrollLeft\n        };\n    }\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction isWithinBoundingY(_a) {\n    var clientY = _a.clientY, rect = _a.rect;\n    return clientY >= rect.top && clientY <= rect.bottom;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction isWithinBoundingX(_a) {\n    var clientX = _a.clientX, rect = _a.rect;\n    return clientX >= rect.left && clientX <= rect.right;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getResizeEdges(_a) {\n    var clientX = _a.clientX, clientY = _a.clientY, elm = _a.elm, allowedEdges = _a.allowedEdges, cursorPrecision = _a.cursorPrecision;\n    /** @type {?} */\n    var elmPosition = elm.nativeElement.getBoundingClientRect();\n    /** @type {?} */\n    var edges = {};\n    if (allowedEdges.left &&\n        isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) &&\n        isWithinBoundingY({ clientY: clientY, rect: elmPosition })) {\n        edges.left = true;\n    }\n    if (allowedEdges.right &&\n        isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) &&\n        isWithinBoundingY({ clientY: clientY, rect: elmPosition })) {\n        edges.right = true;\n    }\n    if (allowedEdges.top &&\n        isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) &&\n        isWithinBoundingX({ clientX: clientX, rect: elmPosition })) {\n        edges.top = true;\n    }\n    if (allowedEdges.bottom &&\n        isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) &&\n        isWithinBoundingX({ clientX: clientX, rect: elmPosition })) {\n        edges.bottom = true;\n    }\n    return edges;\n}\n/** @type {?} */\nvar DEFAULT_RESIZE_CURSORS = Object.freeze({\n    topLeft: 'nw-resize',\n    topRight: 'ne-resize',\n    bottomLeft: 'sw-resize',\n    bottomRight: 'se-resize',\n    leftOrRight: 'col-resize',\n    topOrBottom: 'row-resize'\n});\n/**\n * @param {?} edges\n * @param {?} cursors\n * @return {?}\n */\nfunction getResizeCursor(edges, cursors) {\n    if (edges.left && edges.top) {\n        return cursors.topLeft;\n    }\n    else if (edges.right && edges.top) {\n        return cursors.topRight;\n    }\n    else if (edges.left && edges.bottom) {\n        return cursors.bottomLeft;\n    }\n    else if (edges.right && edges.bottom) {\n        return cursors.bottomRight;\n    }\n    else if (edges.left || edges.right) {\n        return cursors.leftOrRight;\n    }\n    else if (edges.top || edges.bottom) {\n        return cursors.topOrBottom;\n    }\n    else {\n        return '';\n    }\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getEdgesDiff(_a) {\n    var edges = _a.edges, initialRectangle = _a.initialRectangle, newRectangle = _a.newRectangle;\n    /** @type {?} */\n    var edgesDiff = {};\n    Object.keys(edges).forEach(function (edge) {\n        edgesDiff[edge] = (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);\n    });\n    return edgesDiff;\n}\n/** @type {?} */\nvar RESIZE_ACTIVE_CLASS = 'resize-active';\n/** @type {?} */\nvar RESIZE_LEFT_HOVER_CLASS = 'resize-left-hover';\n/** @type {?} */\nvar RESIZE_RIGHT_HOVER_CLASS = 'resize-right-hover';\n/** @type {?} */\nvar RESIZE_TOP_HOVER_CLASS = 'resize-top-hover';\n/** @type {?} */\nvar RESIZE_BOTTOM_HOVER_CLASS = 'resize-bottom-hover';\n/** @type {?} */\nvar RESIZE_GHOST_ELEMENT_CLASS = 'resize-ghost-element';\n/** @type {?} */\nvar MOUSE_MOVE_THROTTLE_MS = 50;\n/**\n * Place this on an element to make it resizable. For example:\n *\n * ```html\n * <div\n *   mwlResizable\n *   [resizeEdges]=\"{bottom: true, right: true, top: true, left: true}\"\n *   [enableGhostResize]=\"true\">\n * </div>\n * ```\n */\nvar ResizableDirective = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function ResizableDirective(platformId, renderer, elm, zone) {\n        this.platformId = platformId;\n        this.renderer = renderer;\n        this.elm = elm;\n        this.zone = zone;\n        /**\n         * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.\n         * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize\n         */\n        this.resizeEdges = {};\n        /**\n         * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.\n         */\n        this.enableGhostResize = false;\n        /**\n         * A snap grid that resize events will be locked to.\n         *\n         * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`\n         */\n        this.resizeSnapGrid = {};\n        /**\n         * The mouse cursors that will be set on the resize edges\n         */\n        this.resizeCursors = DEFAULT_RESIZE_CURSORS;\n        /**\n         * Mouse over thickness to active cursor.\n         * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element\n         */\n        this.resizeCursorPrecision = 3;\n        /**\n         * Define the positioning of the ghost element (can be fixed or absolute)\n         */\n        this.ghostElementPositioning = 'fixed';\n        /**\n         * Allow elements to be resized to negative dimensions\n         */\n        this.allowNegativeResizes = false;\n        /**\n         * The mouse move throttle in milliseconds, default: 50 ms\n         */\n        this.mouseMoveThrottleMS = MOUSE_MOVE_THROTTLE_MS;\n        /**\n         * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.\n         */\n        this.resizeStart = new EventEmitter();\n        /**\n         * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.\n         */\n        this.resizing = new EventEmitter();\n        /**\n         * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.\n         */\n        this.resizeEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.mouseup = new Subject();\n        /**\n         * @hidden\n         */\n        this.mousedown = new Subject();\n        /**\n         * @hidden\n         */\n        this.mousemove = new Subject();\n        this.destroy$ = new Subject();\n        this.resizeEdges$ = new Subject();\n        this.pointerEventListeners = PointerEventListeners.getInstance(renderer, zone);\n    }\n    /**\n     * @hidden\n     */\n    /**\n     * @hidden\n     * @return {?}\n     */\n    ResizableDirective.prototype.ngOnInit = /**\n     * @hidden\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var mousedown$ = merge(this.pointerEventListeners.pointerDown, this.mousedown);\n        /** @type {?} */\n        var mousemove$ = merge(this.pointerEventListeners.pointerMove, this.mousemove).pipe(tap(function (_a) {\n            var event = _a.event;\n            if (currentResize) {\n                event.preventDefault();\n            }\n        }), share());\n        /** @type {?} */\n        var mouseup$ = merge(this.pointerEventListeners.pointerUp, this.mouseup);\n        /** @type {?} */\n        var currentResize;\n        /** @type {?} */\n        var removeGhostElement = function () {\n            if (currentResize && currentResize.clonedNode) {\n                _this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);\n                _this.renderer.setStyle(_this.elm.nativeElement, 'visibility', 'inherit');\n            }\n        };\n        /** @type {?} */\n        var getResizeCursors = function () {\n            return __assign({}, DEFAULT_RESIZE_CURSORS, _this.resizeCursors);\n        };\n        this.resizeEdges$\n            .pipe(startWith(this.resizeEdges), map(function () {\n            return (_this.resizeEdges &&\n                Object.keys(_this.resizeEdges).some(function (edge) { return !!_this.resizeEdges[edge]; }));\n        }), switchMap(function (legacyResizeEdgesEnabled) {\n            return legacyResizeEdgesEnabled ? mousemove$ : EMPTY;\n        }), auditTime(this.mouseMoveThrottleMS), takeUntil(this.destroy$))\n            .subscribe(function (_a) {\n            var clientX = _a.clientX, clientY = _a.clientY;\n            /** @type {?} */\n            var resizeEdges = getResizeEdges({\n                clientX: clientX,\n                clientY: clientY,\n                elm: _this.elm,\n                allowedEdges: _this.resizeEdges,\n                cursorPrecision: _this.resizeCursorPrecision\n            });\n            /** @type {?} */\n            var resizeCursors = getResizeCursors();\n            if (!currentResize) {\n                /** @type {?} */\n                var cursor = getResizeCursor(resizeEdges, resizeCursors);\n                _this.renderer.setStyle(_this.elm.nativeElement, 'cursor', cursor);\n            }\n            _this.setElementClass(_this.elm, RESIZE_LEFT_HOVER_CLASS, resizeEdges.left === true);\n            _this.setElementClass(_this.elm, RESIZE_RIGHT_HOVER_CLASS, resizeEdges.right === true);\n            _this.setElementClass(_this.elm, RESIZE_TOP_HOVER_CLASS, resizeEdges.top === true);\n            _this.setElementClass(_this.elm, RESIZE_BOTTOM_HOVER_CLASS, resizeEdges.bottom === true);\n        });\n        /** @type {?} */\n        var mousedrag = mousedown$\n            .pipe(mergeMap(function (startCoords) {\n            /**\n             * @param {?} moveCoords\n             * @return {?}\n             */\n            function getDiff(moveCoords) {\n                return {\n                    clientX: moveCoords.clientX - startCoords.clientX,\n                    clientY: moveCoords.clientY - startCoords.clientY\n                };\n            }\n            /** @type {?} */\n            var getSnapGrid = function () {\n                /** @type {?} */\n                var snapGrid = { x: 1, y: 1 };\n                if (currentResize) {\n                    if (_this.resizeSnapGrid.left && currentResize.edges.left) {\n                        snapGrid.x = +_this.resizeSnapGrid.left;\n                    }\n                    else if (_this.resizeSnapGrid.right &&\n                        currentResize.edges.right) {\n                        snapGrid.x = +_this.resizeSnapGrid.right;\n                    }\n                    if (_this.resizeSnapGrid.top && currentResize.edges.top) {\n                        snapGrid.y = +_this.resizeSnapGrid.top;\n                    }\n                    else if (_this.resizeSnapGrid.bottom &&\n                        currentResize.edges.bottom) {\n                        snapGrid.y = +_this.resizeSnapGrid.bottom;\n                    }\n                }\n                return snapGrid;\n            };\n            /**\n             * @param {?} coords\n             * @param {?} snapGrid\n             * @return {?}\n             */\n            function getGrid(coords, snapGrid) {\n                return {\n                    x: Math.ceil(coords.clientX / snapGrid.x),\n                    y: Math.ceil(coords.clientY / snapGrid.y)\n                };\n            }\n            return ((/** @type {?} */ (merge(mousemove$.pipe(take(1)).pipe(map(function (coords) { return [, coords]; })), mousemove$.pipe(pairwise())))))\n                .pipe(map(function (_a) {\n                var _b = __read(_a, 2), previousCoords = _b[0], newCoords = _b[1];\n                return [\n                    previousCoords ? getDiff(previousCoords) : previousCoords,\n                    getDiff(newCoords)\n                ];\n            }))\n                .pipe(filter(function (_a) {\n                var _b = __read(_a, 2), previousCoords = _b[0], newCoords = _b[1];\n                if (!previousCoords) {\n                    return true;\n                }\n                /** @type {?} */\n                var snapGrid = getSnapGrid();\n                /** @type {?} */\n                var previousGrid = getGrid(previousCoords, snapGrid);\n                /** @type {?} */\n                var newGrid = getGrid(newCoords, snapGrid);\n                return (previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y);\n            }))\n                .pipe(map(function (_a) {\n                var _b = __read(_a, 2), newCoords = _b[1];\n                /** @type {?} */\n                var snapGrid = getSnapGrid();\n                return {\n                    clientX: Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,\n                    clientY: Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y\n                };\n            }))\n                .pipe(takeUntil(merge(mouseup$, mousedown$)));\n        }))\n            .pipe(filter(function () { return !!currentResize; }));\n        mousedrag\n            .pipe(map(function (_a) {\n            var clientX = _a.clientX, clientY = _a.clientY;\n            return getNewBoundingRectangle((/** @type {?} */ (currentResize)).startingRect, (/** @type {?} */ (currentResize)).edges, clientX, clientY);\n        }))\n            .pipe(filter(function (newBoundingRect) {\n            return (_this.allowNegativeResizes ||\n                !!(newBoundingRect.height &&\n                    newBoundingRect.width &&\n                    newBoundingRect.height > 0 &&\n                    newBoundingRect.width > 0));\n        }))\n            .pipe(filter(function (newBoundingRect) {\n            return _this.validateResize\n                ? _this.validateResize({\n                    rectangle: newBoundingRect,\n                    edges: getEdgesDiff({\n                        edges: (/** @type {?} */ (currentResize)).edges,\n                        initialRectangle: (/** @type {?} */ (currentResize)).startingRect,\n                        newRectangle: newBoundingRect\n                    })\n                })\n                : true;\n        }), takeUntil(this.destroy$))\n            .subscribe(function (newBoundingRect) {\n            if (currentResize && currentResize.clonedNode) {\n                _this.renderer.setStyle(currentResize.clonedNode, 'height', newBoundingRect.height + \"px\");\n                _this.renderer.setStyle(currentResize.clonedNode, 'width', newBoundingRect.width + \"px\");\n                _this.renderer.setStyle(currentResize.clonedNode, 'top', newBoundingRect.top + \"px\");\n                _this.renderer.setStyle(currentResize.clonedNode, 'left', newBoundingRect.left + \"px\");\n            }\n            _this.zone.run(function () {\n                _this.resizing.emit({\n                    edges: getEdgesDiff({\n                        edges: (/** @type {?} */ (currentResize)).edges,\n                        initialRectangle: (/** @type {?} */ (currentResize)).startingRect,\n                        newRectangle: newBoundingRect\n                    }),\n                    rectangle: newBoundingRect\n                });\n            });\n            (/** @type {?} */ (currentResize)).currentRect = newBoundingRect;\n        });\n        mousedown$\n            .pipe(map(function (_a) {\n            var clientX = _a.clientX, clientY = _a.clientY, edges = _a.edges;\n            return (edges ||\n                getResizeEdges({\n                    clientX: clientX,\n                    clientY: clientY,\n                    elm: _this.elm,\n                    allowedEdges: _this.resizeEdges,\n                    cursorPrecision: _this.resizeCursorPrecision\n                }));\n        }))\n            .pipe(filter(function (edges) {\n            return Object.keys(edges).length > 0;\n        }), takeUntil(this.destroy$))\n            .subscribe(function (edges) {\n            if (currentResize) {\n                removeGhostElement();\n            }\n            /** @type {?} */\n            var startingRect = getElementRect(_this.elm, _this.ghostElementPositioning);\n            currentResize = {\n                edges: edges,\n                startingRect: startingRect,\n                currentRect: startingRect\n            };\n            /** @type {?} */\n            var resizeCursors = getResizeCursors();\n            /** @type {?} */\n            var cursor = getResizeCursor(currentResize.edges, resizeCursors);\n            _this.renderer.setStyle(document.body, 'cursor', cursor);\n            _this.setElementClass(_this.elm, RESIZE_ACTIVE_CLASS, true);\n            if (_this.enableGhostResize) {\n                currentResize.clonedNode = _this.elm.nativeElement.cloneNode(true);\n                _this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);\n                _this.renderer.setStyle(_this.elm.nativeElement, 'visibility', 'hidden');\n                _this.renderer.setStyle(currentResize.clonedNode, 'position', _this.ghostElementPositioning);\n                _this.renderer.setStyle(currentResize.clonedNode, 'left', currentResize.startingRect.left + \"px\");\n                _this.renderer.setStyle(currentResize.clonedNode, 'top', currentResize.startingRect.top + \"px\");\n                _this.renderer.setStyle(currentResize.clonedNode, 'height', currentResize.startingRect.height + \"px\");\n                _this.renderer.setStyle(currentResize.clonedNode, 'width', currentResize.startingRect.width + \"px\");\n                _this.renderer.setStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges, resizeCursors));\n                _this.renderer.addClass(currentResize.clonedNode, RESIZE_GHOST_ELEMENT_CLASS);\n                (/** @type {?} */ (currentResize.clonedNode)).scrollTop = (/** @type {?} */ (currentResize.startingRect\n                    .scrollTop));\n                (/** @type {?} */ (currentResize.clonedNode)).scrollLeft = (/** @type {?} */ (currentResize.startingRect\n                    .scrollLeft));\n            }\n            _this.zone.run(function () {\n                _this.resizeStart.emit({\n                    edges: getEdgesDiff({\n                        edges: edges,\n                        initialRectangle: startingRect,\n                        newRectangle: startingRect\n                    }),\n                    rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)\n                });\n            });\n        });\n        mouseup$.pipe(takeUntil(this.destroy$)).subscribe(function () {\n            if (currentResize) {\n                _this.renderer.removeClass(_this.elm.nativeElement, RESIZE_ACTIVE_CLASS);\n                _this.renderer.setStyle(document.body, 'cursor', '');\n                _this.renderer.setStyle(_this.elm.nativeElement, 'cursor', '');\n                _this.zone.run(function () {\n                    _this.resizeEnd.emit({\n                        edges: getEdgesDiff({\n                            edges: (/** @type {?} */ (currentResize)).edges,\n                            initialRectangle: (/** @type {?} */ (currentResize)).startingRect,\n                            newRectangle: (/** @type {?} */ (currentResize)).currentRect\n                        }),\n                        rectangle: (/** @type {?} */ (currentResize)).currentRect\n                    });\n                });\n                removeGhostElement();\n                currentResize = null;\n            }\n        });\n    };\n    /**\n     * @hidden\n     */\n    /**\n     * @hidden\n     * @param {?} changes\n     * @return {?}\n     */\n    ResizableDirective.prototype.ngOnChanges = /**\n     * @hidden\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes.resizeEdges) {\n            this.resizeEdges$.next(this.resizeEdges);\n        }\n    };\n    /**\n     * @hidden\n     */\n    /**\n     * @hidden\n     * @return {?}\n     */\n    ResizableDirective.prototype.ngOnDestroy = /**\n     * @hidden\n     * @return {?}\n     */\n    function () {\n        // browser check for angular universal, because it doesn't know what document is\n        if (isPlatformBrowser(this.platformId)) {\n            this.renderer.setStyle(document.body, 'cursor', '');\n        }\n        this.mousedown.complete();\n        this.mouseup.complete();\n        this.mousemove.complete();\n        this.resizeEdges$.complete();\n        this.destroy$.next();\n    };\n    /**\n     * @private\n     * @param {?} elm\n     * @param {?} name\n     * @param {?} add\n     * @return {?}\n     */\n    ResizableDirective.prototype.setElementClass = /**\n     * @private\n     * @param {?} elm\n     * @param {?} name\n     * @param {?} add\n     * @return {?}\n     */\n    function (elm, name, add) {\n        if (add) {\n            this.renderer.addClass(elm.nativeElement, name);\n        }\n        else {\n            this.renderer.removeClass(elm.nativeElement, name);\n        }\n    };\n    ResizableDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[mwlResizable]'\n                },] }\n    ];\n    /** @nocollapse */\n    ResizableDirective.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n        { type: Renderer2 },\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    ResizableDirective.propDecorators = {\n        validateResize: [{ type: Input }],\n        resizeEdges: [{ type: Input }],\n        enableGhostResize: [{ type: Input }],\n        resizeSnapGrid: [{ type: Input }],\n        resizeCursors: [{ type: Input }],\n        resizeCursorPrecision: [{ type: Input }],\n        ghostElementPositioning: [{ type: Input }],\n        allowNegativeResizes: [{ type: Input }],\n        mouseMoveThrottleMS: [{ type: Input }],\n        resizeStart: [{ type: Output }],\n        resizing: [{ type: Output }],\n        resizeEnd: [{ type: Output }]\n    };\n    return ResizableDirective;\n}());\nvar PointerEventListeners = /** @class */ (function () {\n    function PointerEventListeners(renderer, zone) {\n        this.pointerDown = new Observable(function (observer) {\n            /** @type {?} */\n            var unsubscribeMouseDown;\n            /** @type {?} */\n            var unsubscribeTouchStart;\n            zone.runOutsideAngular(function () {\n                unsubscribeMouseDown = renderer.listen('document', 'mousedown', function (event) {\n                    observer.next({\n                        clientX: event.clientX,\n                        clientY: event.clientY,\n                        event: event\n                    });\n                });\n                unsubscribeTouchStart = renderer.listen('document', 'touchstart', function (event) {\n                    observer.next({\n                        clientX: event.touches[0].clientX,\n                        clientY: event.touches[0].clientY,\n                        event: event\n                    });\n                });\n            });\n            return function () {\n                unsubscribeMouseDown();\n                unsubscribeTouchStart();\n            };\n        }).pipe(share());\n        this.pointerMove = new Observable(function (observer) {\n            /** @type {?} */\n            var unsubscribeMouseMove;\n            /** @type {?} */\n            var unsubscribeTouchMove;\n            zone.runOutsideAngular(function () {\n                unsubscribeMouseMove = renderer.listen('document', 'mousemove', function (event) {\n                    observer.next({\n                        clientX: event.clientX,\n                        clientY: event.clientY,\n                        event: event\n                    });\n                });\n                unsubscribeTouchMove = renderer.listen('document', 'touchmove', function (event) {\n                    observer.next({\n                        clientX: event.targetTouches[0].clientX,\n                        clientY: event.targetTouches[0].clientY,\n                        event: event\n                    });\n                });\n            });\n            return function () {\n                unsubscribeMouseMove();\n                unsubscribeTouchMove();\n            };\n        }).pipe(share());\n        this.pointerUp = new Observable(function (observer) {\n            /** @type {?} */\n            var unsubscribeMouseUp;\n            /** @type {?} */\n            var unsubscribeTouchEnd;\n            /** @type {?} */\n            var unsubscribeTouchCancel;\n            zone.runOutsideAngular(function () {\n                unsubscribeMouseUp = renderer.listen('document', 'mouseup', function (event) {\n                    observer.next({\n                        clientX: event.clientX,\n                        clientY: event.clientY,\n                        event: event\n                    });\n                });\n                unsubscribeTouchEnd = renderer.listen('document', 'touchend', function (event) {\n                    observer.next({\n                        clientX: event.changedTouches[0].clientX,\n                        clientY: event.changedTouches[0].clientY,\n                        event: event\n                    });\n                });\n                unsubscribeTouchCancel = renderer.listen('document', 'touchcancel', function (event) {\n                    observer.next({\n                        clientX: event.changedTouches[0].clientX,\n                        clientY: event.changedTouches[0].clientY,\n                        event: event\n                    });\n                });\n            });\n            return function () {\n                unsubscribeMouseUp();\n                unsubscribeTouchEnd();\n                unsubscribeTouchCancel();\n            };\n        }).pipe(share());\n    }\n    // tslint:disable-line\n    /**\n     * @param {?} renderer\n     * @param {?} zone\n     * @return {?}\n     */\n    PointerEventListeners.getInstance = \n    // tslint:disable-line\n    /**\n     * @param {?} renderer\n     * @param {?} zone\n     * @return {?}\n     */\n    function (renderer, zone) {\n        if (!PointerEventListeners.instance) {\n            PointerEventListeners.instance = new PointerEventListeners(renderer, zone);\n        }\n        return PointerEventListeners.instance;\n    };\n    return PointerEventListeners;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An element placed inside a `mwlResizable` directive to be used as a drag and resize handle\n *\n * For example\n *\n * ```html\n * <div mwlResizable>\n *   <div mwlResizeHandle [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * </div>\n * ```\n */\nvar ResizeHandleDirective = /** @class */ (function () {\n    function ResizeHandleDirective(renderer, element, zone, resizable) {\n        this.renderer = renderer;\n        this.element = element;\n        this.zone = zone;\n        this.resizable = resizable;\n        /**\n         * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on\n         */\n        this.resizeEdges = {};\n        this.eventListeners = {};\n    }\n    /**\n     * @return {?}\n     */\n    ResizeHandleDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.unsubscribeEventListeners();\n    };\n    /**\n     * @hidden\n     */\n    /**\n     * @hidden\n     * @param {?} event\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    ResizeHandleDirective.prototype.onMousedown = /**\n     * @hidden\n     * @param {?} event\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    function (event, clientX, clientY) {\n        var _this = this;\n        event.preventDefault();\n        this.zone.runOutsideAngular(function () {\n            if (!_this.eventListeners.touchmove) {\n                _this.eventListeners.touchmove = _this.renderer.listen(_this.element.nativeElement, 'touchmove', function (touchMoveEvent) {\n                    _this.onMousemove(touchMoveEvent, touchMoveEvent.targetTouches[0].clientX, touchMoveEvent.targetTouches[0].clientY);\n                });\n            }\n            if (!_this.eventListeners.mousemove) {\n                _this.eventListeners.mousemove = _this.renderer.listen(_this.element.nativeElement, 'mousemove', function (mouseMoveEvent) {\n                    _this.onMousemove(mouseMoveEvent, mouseMoveEvent.clientX, mouseMoveEvent.clientY);\n                });\n            }\n            _this.resizable.mousedown.next({\n                clientX: clientX,\n                clientY: clientY,\n                edges: _this.resizeEdges\n            });\n        });\n    };\n    /**\n     * @hidden\n     */\n    /**\n     * @hidden\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    ResizeHandleDirective.prototype.onMouseup = /**\n     * @hidden\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    function (clientX, clientY) {\n        var _this = this;\n        this.zone.runOutsideAngular(function () {\n            _this.unsubscribeEventListeners();\n            _this.resizable.mouseup.next({\n                clientX: clientX,\n                clientY: clientY,\n                edges: _this.resizeEdges\n            });\n        });\n    };\n    /**\n     * @private\n     * @param {?} event\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    ResizeHandleDirective.prototype.onMousemove = /**\n     * @private\n     * @param {?} event\n     * @param {?} clientX\n     * @param {?} clientY\n     * @return {?}\n     */\n    function (event, clientX, clientY) {\n        this.resizable.mousemove.next({\n            clientX: clientX,\n            clientY: clientY,\n            edges: this.resizeEdges,\n            event: event\n        });\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    ResizeHandleDirective.prototype.unsubscribeEventListeners = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        Object.keys(this.eventListeners).forEach(function (type) {\n            ((/** @type {?} */ (_this))).eventListeners[type]();\n            delete _this.eventListeners[type];\n        });\n    };\n    ResizeHandleDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[mwlResizeHandle]'\n                },] }\n    ];\n    /** @nocollapse */\n    ResizeHandleDirective.ctorParameters = function () { return [\n        { type: Renderer2 },\n        { type: ElementRef },\n        { type: NgZone },\n        { type: ResizableDirective }\n    ]; };\n    ResizeHandleDirective.propDecorators = {\n        resizeEdges: [{ type: Input }],\n        onMousedown: [{ type: HostListener, args: ['touchstart', [\n                        '$event',\n                        '$event.touches[0].clientX',\n                        '$event.touches[0].clientY'\n                    ],] }, { type: HostListener, args: ['mousedown', ['$event', '$event.clientX', '$event.clientY'],] }],\n        onMouseup: [{ type: HostListener, args: ['touchend', [\n                        '$event.changedTouches[0].clientX',\n                        '$event.changedTouches[0].clientY'\n                    ],] }, { type: HostListener, args: ['touchcancel', [\n                        '$event.changedTouches[0].clientX',\n                        '$event.changedTouches[0].clientY'\n                    ],] }, { type: HostListener, args: ['mouseup', ['$event.clientX', '$event.clientY'],] }]\n    };\n    return ResizeHandleDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ResizableModule = /** @class */ (function () {\n    function ResizableModule() {\n    }\n    ResizableModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [ResizableDirective, ResizeHandleDirective],\n                    exports: [ResizableDirective, ResizeHandleDirective]\n                },] }\n    ];\n    return ResizableModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { ResizableDirective, ResizeHandleDirective, ResizableModule };\n"]}